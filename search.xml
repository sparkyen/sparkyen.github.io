<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo的next主题个性化</title>
    <url>/posts/28378.html</url>
    <content><![CDATA[<ul>
<li><p>开启自定义样式 <pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">custom_file_path</span><span class="token punctuation">:</span>
  <span class="token key atrule">style</span><span class="token punctuation">:</span> source/_data/styles.styl</code></pre></p>
<p>并增加如下样式覆盖：</p>
<p><pre class="language-css" data-language="css"><code class="language-css"><span class="token selector">.posts-expand .post-header</span> <span class="token punctuation">&#123;</span>
  //改到左边
  <span class="token property">text-align</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.posts-expand .post-meta-container</span> <span class="token punctuation">&#123;</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> 6px<span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>
 
<span class="token selector">.posts-expand .post-header</span> <span class="token punctuation">&#123;</span>
  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></p></li>
<li><p>取消meta自适应：<code>source\css\_common\components\post\post-header.styl</code></p>
<p><pre class="language-css" data-language="css"><code class="language-css"><span class="token selector">.post-meta</span> <span class="token punctuation">&#123;</span>
  //<span class="token function">flex-wrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></p></li>
<li><p>给首先文章标题增加小旗子：<code>layout\_macro\post.njk</code>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;&#123;% if is_index %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125; class="post-title&#123;% if post.direction and post.direction.toLowerCase() === 'rtl' %&#125; rtl&#123;% endif %&#125;" itemprop="name headline">
          &#123;# Link posts #&#125;
          &#123;%- if post.link %&#125;
            &#123;%- if post.sticky > 0 %&#125;
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post-sticky-flag<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;&#123; __(<span class="token punctuation">'</span>post.sticky<span class="token punctuation">'</span>) &#125;&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fa fa-thumbtack<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
            &#123;%- endif %&#125;
            &#123;%- set postTitleIcon = '<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fa fa-external-link-alt<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>' %&#125;
            &#123;%- set postText = post.title or post.link %&#125;
            ⚑&amp;nbsp&#123;&#123;- next_url(post.link, postText + postTitleIcon, &#123;class: 'post-title-link post-title-link-external', itemprop: 'url'&#125;) &#125;&#125;
          &#123;% elif is_index %&#125;
            &#123;%- if post.sticky > 0 %&#125;
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post-sticky-flag<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;&#123; __(<span class="token punctuation">'</span>post.sticky<span class="token punctuation">'</span>) &#125;&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fa fa-thumbtack<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
            &#123;%- endif %&#125;
			⚑&amp;nbsp&#123;&#123;- next_url(post.path, post.title or __('post.untitled'), &#123;class: 'post-title-link', itemprop: 'url'&#125;) &#125;&#125;
          &#123;%- else %&#125;
            &#123;&#123;- post.title &#125;&#125;
            &#123;&#123;- post_edit(post.source) &#125;&#125;
          &#123;%- endif %&#125;
        &lt;/&#123;% if is_index %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125;></code></pre></p></li>
<li><p>增加首页博文的meta，以便显示tag信息：<code>layout\_partials\post\post-meta.njk</code></p>
<p><pre class="language-markup" data-language="markup"><code class="language-markup">&#123;# Tag 信息显示 #&#125;
&#123;%- if post.tags and post.tags.length and theme.post_meta.tags %&#125;
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post-meta-item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post-meta-item-icon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>far fa-folder<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post-meta-item-text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; __('post.in') &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
  &#123;%- set tag_indicate = '<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fa fa-tag<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>' if theme.tag_icon else '#' %&#125;
  &#123;%- for tag in post.tags.toArray() %&#125;
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;&#123; url_for(tag.path) &#125;&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tag<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> &#123;&#123; tag.name &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token entity named-entity" title="&ensp;">&amp;ensp;</span>
  &#123;%- endfor %&#125;
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
&#123;%- endif %&#125;</code></pre></p></li>
</ul>
]]></content>
      <tags>
        <tag>publication</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP赛前总结</title>
    <url>/posts/34065.html</url>
    <content><![CDATA[<h2 id="oi-赛事与赛制">OI 赛事与赛制</h2>
<h3 id="赛事简介">赛事简介</h3>
<p><strong>信息学奥林匹克竞赛</strong>（英语：Olympiad in
Informatics，简称：OI）是一门在中学生中广泛开展的学科竞赛，和物理、数学等竞赛性质相同。OI
考察的内容是参赛者运用算法、数据结构和数学知识，通过编写计算机程序解决实际问题的能力。</p>
<p>OI 竞赛种类繁多，仅中国就包括：</p>
<ul>
<li>全国青少年信息学奥林匹克联赛（NOIP）</li>
<li>全国青少年信息学奥林匹克竞赛（NOI）</li>
<li>全国青少年信息学奥林匹克竞赛冬令营（WC）</li>
<li>国际信息学奥林匹克竞赛中国队选拔赛（CTSC）</li>
</ul>
<p>国际性的 OI 竞赛包括：</p>
<ul>
<li>国际信息学奥林匹克（IOI）</li>
<li>美国计算机奥林匹克竞赛（USACO）<br />
……</li>
</ul>
<p>对于大部分选手而言，每年的新赛季从 10 月的 NOIP 开始。</p>
<p>OI 竞赛中允许使用的语言包括 C、C++ 和 Pascal（NOI 已于 2020
年停止使用 Pascal，NOIP 将于 2022 年停止使用
Pascal）。其中，不同的竞赛对 C++
的版本有不同的规定。考试题目一般为算法或者数据结构相关的内容，题目形式包括传统题（最常见的规定输入和输出到文件的题目）和非传统题（提交答案题、交互题、补全代码题……等等）。</p>
<h3 id="赛制介绍">赛制介绍</h3>
<h4 id="oi-赛制">OI 赛制</h4>
<p>一般的 OI 赛制可以理解为单人在 5 个小时的时间内尝试解决 3 道题。</p>
<p>选手仅有一次提交机会。比赛时无法看到评测结果，评分会在赛后公布。每道题都有多个测试点，根据每道题通过的测试点的数量获得相应的分数；每个测试点还可能会有部分分，即使只有部分数据通过也能拿到分数。</p>
<p>NOIP、NOI、省选都是 OI 赛制。</p>
<h4 id="ioi-赛制">IOI 赛制</h4>
<p>选手在比赛时有多次提交机会。比赛实时评测并返回结果，如果提交的结果是错误的，不会有任何惩罚。每道题都有多个测试点，根据每道题通过的测试点的数量获得相应的分数。</p>
<p>APIO、IOI 都是 IOI 赛制。目前国内比赛也在逐渐向 IOI 赛制靠拢。</p>
<h4 id="codeforces-cf-赛制">Codeforces (CF) 赛制</h4>
<p><a
href="https://codeforces.com/">Codeforces</a> 是一个在线评测系统，会定期举办比赛。</p>
<p>它的比赛特点是在比赛过程中只测试一部分数据（pretests），而在比赛结束后返回完整的所有测试点的测试结果（system
tests）。比赛时可以多次提交，允许 hack 别人的代码（此处 hack
的意思是提交一个测试数据，使得别人的代码无法给出正确答案）。如果想要
hack，选手必须要锁定自己的代码（换言之，比赛时无法重新提交该题）。Hack
时不允许将选手程序拷贝到本地进行测试，源代码会被转换成图片。</p>
<p>Codeforces 同时提供另外一种赛制，称作扩展 ICPC（extended
ICPC）。在这一赛制中，在比赛过程中会测试全部数据，但比赛结束以后会有 12
小时的全网 hack 时间。Hack 时允许将选手程序拷贝到本地进行测试。</p>
<h4 id="acm赛制">ACM赛制</h4>
<p>一般是三个人组成一队使用一台机器，在比赛时有多次提交机会。比赛实时评测并返回结果，如果提交的结果错误会有
20
分钟的罚时，错误次数越多，加罚的时间也越长。每个题目只有在所有数据点全部正确后才能得到分数。比赛排名根据做题数来评判，做题数相同的，根据总用时来评判。总用时是每题用时的和。每题的用时是从比赛开始到做出该题的分钟数与该题的罚时之和。</p>
<p>一些 ICPC
相关赛事中，比赛结束前一小时进行封榜，封榜后的提交和排名将无法被其他选手看见。</p>
<p>在 ICPC 相关赛事中，选手允许带一定量的纸质资料。</p>
<p>除 ICPC 和 CCPC 外，众多比赛也采用该赛制，如 LeetCode
周赛及全国编程大赛、牛客小白赛练习赛挑战赛等。</p>
<h3 id="主要比赛">主要比赛</h3>
<h4 id="noip">NOIP</h4>
<p><strong>NOIP</strong>（英语：National Olympiad in Informatics in
Provinces，中文：全国青少年信息学奥林匹克联赛）是中华人民共和国组织的、面向中国（含港澳）中学生的信息学竞赛。</p>
<p>NOIP 以省为单位排名评奖。截至 2019
年，大部分高校的选手获得提高组省一等奖可以得到自主招生资格。</p>
<p>NOIP 按参赛对象分为普及组和提高组，2018
年于上海试点入门组；按阶段分为初赛和复赛两个阶段。初赛会考察一些计算机基础知识和算法基础，复赛为上机考试。时间上一般是
11 月的第二个周末，周六上午提高组一试 8:30-12:00（3.5 小时，共 3
题），下午 14:30-18:00 普及组（3.5 小时，共 4 题），周日上午提高组二试
8:30-12:00（3.5 小时，共 3
题）。全国使用同一套试卷，但是评奖规则按照省内情况由
CCF（中国计算机学会）统一指定，并于赛后在 <a
href="http://www.noi.cn/">NOI
官方网站</a> 上公布。各省的一等奖分数线略有不同。</p>
<p>NOIP 于 2019 年 8 月 16 日 <a
href="http://www.noi.cn/xw/2019-08-16/715365.shtml">被 CCF 暂停</a>，于
2020 年 1 月 21 日 <a
href="http://www.noi.cn/xw/2020-01-21/715520.shtml">被宣布恢复</a>。</p>
<h4 id="csp-js">CSP J/S</h4>
<p><strong>CSP</strong>（英文：Certified Software Professional
Junior/Senior) 是 NOIP 在 2019 年被取消之后，CCF
开设的非专业级软件能力认证，面向全年龄段。具体赛制、时间基本同 NOIP
一致。在部分地区，CSP 2019 设有小学组。</p>
<p>目前暂不清楚获得 CSP J/S 认证对自主招生资格的获取是否有帮助。</p>
<h4 id="省队选拔赛">省队选拔赛</h4>
<p><strong>省队选拔赛</strong>（简称：省选）用于选拔各省参加全国赛的代表队。</p>
<p>省选题目由各个省自行决定，目前的趋势是很多省份选择联合命题。</p>
<p>各个省队的名额有复杂的计算公式，一般和之前的成绩和参赛人数有关。通常来讲，NOIP
分数需要在省选的指标中占一定比例。根据规则，初中选手只能被选拔为 E
类选手，不能参加 A、B 类选拔。A 类选手有 5 人（4 男 1
女），其他选手根据给定名额和所得分数依次进入 B 队。一个学校参加 NOI
的名额不超过本省 A、B 名额总数的三分之一（四舍五入），得分最高且入选 A
队的女选手不占该比例（简称 ⅓ 限制或 ⅓ 淘汰）。</p>
<p>自 2020 年起，NOI 省队选拔由 CCF
统一命题和评测，有能力命题的省可自行命题，但选拔方式需得到 CCF
的批准。</p>
<h4 id="noi">NOI</h4>
<p><strong>NOI</strong>（英文：National Olympiad in
Informatics，中文：全国信息学奥林匹克竞赛）是国内包括港澳在内的省级代表队最高水平的大赛。</p>
<p>NOI 一般在七月份举行，有现场赛和网络赛。现场赛选手分为五类，其中
A、B、C 类为正式选手，D、E 类选手为邀请赛选手。A、B 类对应省队的 A、B
类选手（其中 A 类在计算成绩时会有 5 分加分）；C 类名义上是学校对 CCF
做出突出贡献后的奖励名额；D 类名义上是个人对 CCF
做出突出贡献后的奖励名额（基本为大额捐款）；E
类选手为初中组选手，如果成绩超过分数线的话，只有成绩证明而没有奖牌（同等分数含金量要低一些）。正式选手前
50 名组成国家集训队，获得保送资格。网络赛报名形式上没有门槛。</p>
<p>在国际平台上，为了与其他同样称作 NOI 的比赛区分，有时会被称作
CNOI。</p>
<h4 id="wc">WC</h4>
<p><strong>WC</strong>（英文：Winter
Camp，中文：全国青少年信息学奥林匹克竞赛冬令营 ）是每年冬天在当年 NOI
举办地进行的一项活动。</p>
<p>WC
的内容包括若干天的培训和一天的考试。这项考试主要用于从国家集训队（50
人）选拔国家候选队（15 人），但是前一年 NOIP
取得较好成绩的选手也可以参加（不参与选拔）。</p>
<h2 id="算法评估与复杂度">算法评估与复杂度</h2>
<h3 id="如何评价算法">如何评价算法</h3>
<p>算法竞赛一般采用黑箱测试法来测试选手的程序。进行测试时,把程序看作一个不能打开的“黑盒子”。将输入数据调入这个黑盒子,观察这个黑盒子返回的结果是否正确(是否符合期望),而不关心程序内是如何实现的。</p>
<p>对于算法竞赛的评价机制来说,选手必须在限定的时间按题目要求写出程序;这些程序必须在限制的时间内存之内运行完毕,并根据测试数据给出正确的答案。这就要求选手的程序达到以下要求。</p>
<p><strong>(1）代码可实现</strong><br />
按照编程者的能力可以将算法通过代码实现出来。如果能想出算法但是无法实现,或者需要花费非常多(超过比赛时间)的时间和行数才能编写出来,那也是不行的。</p>
<p><strong>(2) 结果正确</strong><br />
程序能够运行完毕,不会在运行的过程中出错崩溃。输出的结果必须符合期望才能通过这个测试点。</p>
<p><strong>(3）能在限定的时间内运行完毕</strong><br />
在结果正确的前提下,运行程序的时间越短越好。对于一些数据量较大的题目,需要尽力去优化程序的运行时间,否则会因为运行超时而不能通过这些测试点。</p>
<p><strong>(4) 不超过内存等资源限制</strong><br />
计算机内存是有限的,所以使用过多的内存也是不行的。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<p>一个程序在写出来之前是无法准确估计实际运行时间的。但是几乎所有算法竞赛的任务都会告知输入数据的规模和运行时间限制，这就允许选手通过分析算法的时间复杂度,从而事先估计能丕在限定的时间内运行完程序。</p>
<p><strong>时间复杂度举例</strong></p>
<ul>
<li><span class="math inline">\(O(1)\)</span>—常数条语句：交换两个元素
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 输入</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> 
<span class="token comment">// 计算 int t = a; </span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span> 
b <span class="token operator">=</span> t<span class="token punctuation">;</span></code></pre></li>
<li><span class="math inline">\(O(n)\)</span>—单重循环求数组和
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 输入 int a[] = &#123;2, 0, 1, 3, 5&#125;; </span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
	sum <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></li>
<li><span class="math inline">\(O(\log n)\)</span>—二分
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
 <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>x<span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>
	<span class="token keyword">else</span> l <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre></li>
<li><span
class="math inline">\(O(n^2)\)</span>—双重循环求数组中相等元素对数
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 输入 int a[] = &#123;1, 1, 3, 5, 5&#125;; </span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 计算 int cnt = 0; </span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> 
	cnt <span class="token operator">+=</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </code></pre></li>
<li><span class="math inline">\(O(2^n)\)</span>—枚举<span
class="math inline">\(n\)</span>个数字组成集合的所有子集，输出子集和。
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 输入 int a[] = &#123;2, 1, 3, 6, 5&#125;; </span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> 
<span class="token comment">// 计算 </span>
<span class="token keyword">int</span> tot <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 相当于求2的5次方 </span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tot<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
	<span class="token comment">// 变量i的二进制形式用于表示每个元素选（1）与不选（0）。 </span>
	<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> 
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">>></span> j<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> sum <span class="token operator">+=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 检查i的第j位是否是1 </span>
	cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<p>在竞赛中，一般算机一秒能运行 <span class="math inline">\((5 \times
10^8)\)</span>次计算</p>
<blockquote>
<p><span class="math inline">\(O(n)\)</span>的算法数据范围 <span
class="math inline">\((n &lt;= 10^8)\)</span>。<br />
<span class="math inline">\(O(n\log n)\)</span>的算法数据范围 <span
class="math inline">\((n &lt;= 10^6)\)</span>。<br />
<span class="math inline">\(O(n\sqrt[]{n})\)</span>的算法数据范围 <span
class="math inline">\((n &lt;= 10^5)\)</span>。<br />
<span class="math inline">\(O(n^{2})\)</span>的算法数据范围 <span
class="math inline">\((n &lt;= 5000)\)</span>。<br />
<span class="math inline">\(O(n^{3})\)</span>的算法数据范围 <span
class="math inline">\((n &lt;300)\)</span><br />
<span class="math inline">\(O(2^{n})\)</span>的算法数据范围 <span
class="math inline">\((n &lt; 25)\)</span>。<br />
<span class="math inline">\(O(n!)\)</span>的算法数据范围 <span
class="math inline">\((n &lt; 11)\)</span>。</p>
</blockquote>
<p>则我们可以根据对应的数据范围选择合适的算法<br />
<span class="math inline">\(n \leq 200\)</span>,可以选择复杂度为<span
class="math inline">\(O(n3)\)</span>的算法。例如：floyd<br />
<span class="math inline">\(n \leq 5000\)</span>，可以选择复杂度为<span
class="math inline">\(O(n2)\)</span>的算法。例如：dp, 朴素版Prim<br />
<span class="math inline">\(n \leq 10^6\)</span>,可以选择复杂度为<span
class="math inline">\(O(nlogn)\)</span>的算法。<br />
<span class="math inline">\(n \leq 10^8\)</span>，可以选择复杂度为<span
class="math inline">\(O(n)\)</span>的算法。<br />
<span class="math inline">\(n \leq 10^9\)</span>，可以选择复杂度为<span
class="math inline">\(O(\sqrt{n})\)</span>的算法。例如：判断质数<br />
<span class="math inline">\(n \leq
10^{18}\)</span>，可以选择复杂度为<span class="math inline">\(O(log\
n)\)</span>的算法。例如：二分，欧几里得算法，幂运算</p>
<p>以上仅为参考，实际做题还需考虑具体数据细节。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>评价算法优劣程度的另外一个重要标准就是占用内存空间的大小,也就是空间复杂度。相比于时间复杂度,空间复杂度相对没那么受到关注,因为多数情况下内存限制还是比较宽裕的,一般是数百兆字节(MB)。但是这并不意味着内存可以敞开使用,因为一旦超过了给定的内存限制,即使能够在规定时间给出正确答案,也不能得分。因此,需要特别注意自己的程序会不会内存超限。</p>
<p>程序运行的内存也是可以估计的。设立数组、使用STL
容器存储内容、运行递归函数、建立动态对象等行为都会占用内存。其中定义数组所占用的空间最容易事前估计。</p>
<p>以<span class="math inline">\(128MB\)</span>为例，<span
class="math inline">\(128M=131072KB=134217728\)</span>字节</p>
<p><span class="math inline">\(int=4\)</span>字节<br />
<span class="math inline">\(char=1\)</span>字节<br />
<span class="math inline">\(long long=8\)</span>字节</p>
<p>开<span class="math inline">\(int\)</span>型变量的一维数组最多是<span
class="math inline">\(3∗10^7\)</span>，<span class="math inline">\(long
long\)</span>为<span class="math inline">\(1.5*10^7\)</span>，<span
class="math inline">\(char\)</span>型<span
class="math inline">\(1.3*10^8\)</span>左右。</p>
<p>如果输入数据规模是<span
class="math inline">\(n\)</span>,建立一个<span
class="math inline">\(n\times
n\)</span>大小的二维数组,那么其空间复杂度是<span
class="math inline">\(O(n^2)\)</span>。<span
class="math inline">\(128MB\)</span>最多能存储<span
class="math inline">\(5600\times 5600\)</span>的二维<span
class="math inline">\(int\)</span>数组(即使矩阵的元素只访问常数次数,其时间复杂度也会导致运行时间不短了)。所以千万别考虑建立一个<span
class="math inline">\(a[100000][ 100000
]\)</span>这样的二维数组。而建立多维数组时更是要小心,一定要提前计算将占用的内存,以免内存超限。</p>
<p>有些题目为了增加难度,会对内存进行限制,由于内存只限制几兆字节,同时输入数据又很多,因此无法开设数组存人所有的数据。这就要求必须将数据读入后立刻处理然后抛弃,这就是在线算法，对思维要求更高了。</p>
<h3 id="非完美算法">非完美算法</h3>
<p>在各类程序设计竞赛中,选手都希望能在自己有限的水平下尽可能获得多的分数。有的比赛,例如ICPC,要求选手必须通过全部的测试点才能获得这道题的分数;而有的竞赛,例如NOI系列比赛,会将一道题的测试数据分为若干子任务,即使仅通过了部分测试数据,也可以获得部分分数。</p>
<p>完全写对一道题目的正确解法可能很难,但是可以通过一些策略写出一个能够通过部分子任务的“非完美算法”.从而获得部分分数。获得部分分数的思路主要有以下几方面。</p>
<p><strong>思路1:完成较小的数据范围的高复杂度方法。</strong><br />
测试数据的数据范围是有梯度的。如果选手无法想到正确的解法,可以尝试使用枚举、搜索等效率较低的算法完成题意要求。尽管暴力算法的时间复杂度高，但是可以通过一些较小数据范围的子任务,获得一些分数。</p>
<p>有些题目的正确解法是在暴力解法的基础上优化复杂度的,因此可以尝试找到算法的瓶颈,看看是否有办法通过减少枚举量和使用各种算法工具来优化时间复杂度,从而缩短程序的运行时间。</p>
<p><strong>思路2:解决部分特殊情况。</strong><br />
在NOI系列比赛中,有些部分的分数虽然数据范围不小,但是限定了一些特殊情况(例如将树结构退化成链状结构、某些题目规定的情况不会存在等)。这样就可以针对这些特殊情况的特性专门解决这个子任务。虽然这样的算法对于整个题目来说是错误的,但是适用于一些特殊情况,对于这些特殊情况来说是正解。由于只需要考虑这样的特殊情况,所以思维难度会有所降低。</p>
<p>同一个题目可能会有多种特殊情况。选手可以针对每一种特殊情况单独写出对应的算法，然后判断输入数据符合哪一种情况，对这种情况专门进行计算。这样也可以获得力所能及的分数。</p>
<p>平时练习在面对一些难度较大的题目，可以分析子任务，写出一些非完美解法,通过尽可能多的子任务。这样在竞赛场上,就可以在自己的能力范围内获得尽可能高的分数了。</p>
<h2 id="算法竞赛的技巧">算法竞赛的技巧</h2>
<h3 id="读入与输出">读入与输出</h3>
<h4 id="文件操作">文件操作</h4>
<h5 id="文件的概念">文件的概念</h5>
<p>文件是根据特定的目的而收集在一起的有关数据的集合。C/C++
把每一个文件都看成是一个有序的字节流，每个文件都是以 <strong>文件结束标志</strong>（EOF）结束，如果要操作某个文件，程序应该首先打开该文件，每当一个文件被打开后（请记得关闭打开的文件），该文件就和一个流关联起来，这里的流实际上是一个字节序列。</p>
<h5 id="文件的操作步骤">文件的操作步骤</h5>
<p>1、打开文件，将文件指针指向文件，决定打开文件类型；<br />
2、对文件进行读、写操作<br />
3、在使用完文件后，关闭文件。</p>
<h5 id="freopen-函数">freopen 函数</h5>
<h6 id="函数简介">函数简介</h6>
<p>函数用于将指定输入输出流以指定方式重定向到文件，包含于头文件 <code>stdio.h (cstdio)</code> 中</p>
<p>我们主要使用函数的两种方式：读、写</p>
<h6 id="命令格式">命令格式</h6>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">FILE<span class="token operator">*</span> <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> mode<span class="token punctuation">,</span> FILE<span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h6 id="参数说明">参数说明</h6>
<ul>
<li><code>filename</code>: 要打开的文件名</li>
<li><code>mode</code>: 文件打开的模式，表示文件访问的权限</li>
<li><code>stream</code>: 文件指针，通常使用标准文件流
(<code>stdin/stdout</code>) 或标准错误输出流 (<code>stderr</code>)</li>
<li>返回值：文件指针，指向被打开文件</li>
</ul>
<h6 id="文件打开格式">文件打开格式</h6>
<ul>
<li><code>r</code>：以只读方式打开文件，文件必须存在，只允许读入数据</li>
<li><code>w</code>：以只写方式打开文件，文件不存在会新建文件，否则清空内容，只允许写入数据</li>
</ul>
<h6 id="使用方法">使用方法</h6>
<p>读入文件内容：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"data.in"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// data.in 就是读取的文件名，要和可执行文件放在同一目录下</span></code></pre>
<p>输出到文件：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"data.out"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// data.out 就是输出文件的文件名，和可执行文件在同一目录下</span></code></pre>
<p>关闭标准输入/输出流</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">fclose</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">fclose</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong><code>提示</code></strong><br />
<code>printf/scanf/cin/cout</code> 等函数默认使用 <code>stdin/stdout</code>，将 <code>stdin/stdout</code> 重定向后，这些函数将输入/输出到被定向的文件</p>
<h6 id="模板">模板</h6>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"data.in"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"data.out"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*
  中间的代码不需要改变，直接使用 cin 和 cout 即可
  */</span>
  <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h4 id="优化">优化</h4>
<p>在不改变算法复杂度但是可以加快程序运行速度的方法被称为<strong>常数优化</strong>。其中常数的意思为，我们评估一个算法时间复杂度为<span
class="math inline">\(O(n)\)</span>，其时间复杂度必定会带上一个常系数<span
class="math inline">\(k\)</span>，总体就是<span
class="math inline">\(k*n\)</span>。</p>
<p>在默认情况下，<code>std::cin/std::cout</code> 是极为迟缓的读入/输出方式，而 <code>scanf/printf</code> 比 <code>std::cin/std::cout</code> 快得多。</p>
<h5 id="关闭同步解除绑定">关闭同步/解除绑定</h5>
<h6
id="stdiossync_with_stdiofalse"><code>std::ios::sync_with_stdio(false)</code></h6>
<p>这个函数是一个“是否兼容 stdio”的开关，C++ 为了兼容
C，保证程序在使用了 <code>printf</code> 和 <code>std::cout</code> 的时候不发生混乱，将输出流绑到了一起。同步的输出流是线程安全的。</p>
<p>这其实是 C++
为了兼容而采取的保守措施，也是使 <code>cin</code>/<code>cout</code> 速度较慢的主要原因。我们可以在进行
IO 操作之前将 stdio
解除绑定，但是在这样做之后要注意不能同时使用 <code>std::cin</code> 和 <code>scanf</code>，也不能同时使用 <code>std::cout</code> 和 <code>printf</code>，但是可以同时使用 <code>std::cin</code> 和 <code>printf</code>，也可以同时使用 <code>scanf</code> 和 <code>std::cout</code>。</p>
<h6 id="tie"><code>tie</code></h6>
<p>tie 是将两个 stream 绑定的函数，空参数的话返回当前的输出流指针。</p>
<p>在默认的情况下 <code>std::cin</code> 绑定的是 <code>std::cout</code>，每次执行 <code>&lt;&lt;</code> 操作符的时候都要调用 <code>flush()</code> 来清理
stream buffer，这样会增加 IO
负担。可以通过 <code>std::cin.tie(0)</code>（0 表示
NULL）来解除 <code>std::cin</code> 与 <code>std::cout</code> 的绑定，进一步加快执行效率。</p>
<p>但需要注意的是，在解除了 <code>std::cin</code> 和 <code>std::cout</code> 的绑定后，程序中必须手动 <code>flush</code> 才能确保每次 <code>std::cout</code> 展现的内容可以在 <code>std::cin</code> 前出现。这是因为 <code>std::cout</code> 被
buffer 为默认设置。例如：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout
    <span class="token operator">&lt;&lt;</span> <span class="token string">"Please input your name: "</span>
    <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>flush<span class="token punctuation">;</span>  <span class="token comment">// 或者: std::endl;</span>
                    <span class="token comment">// 因为每次调用std::endl都会flush输出缓冲区，而 \n 则不会。</span>
<span class="token comment">// 但请谨慎使用，过多的flush会影响程序效率</span>
std<span class="token double-colon punctuation">::</span>cin <span class="token operator">>></span> name<span class="token punctuation">;</span></code></pre>
<h6 id="代码实现">代码实现</h6>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在算法竞赛中，程序需要考虑的一个重头就是时间复杂度。而对于省选或者ACM这样的大型比赛，卡常是家常便饭的事。<code>scanf</code> 和 <code>printf</code> 依然有优化的空间，这就是接下来介绍的内容—读入和输出优化。</p>
<p><strong><code>注意</code></strong><br />
下面介绍的读入和输出优化均针对整型数据，若要支持其他类型的数据（如浮点数），可自行按照下面介绍的优化原理来编写代码。</p>
<h5 id="输入优化">输入优化</h5>
<p><strong>原理</strong><br />
众所周知，<code>getchar</code> 是用来读入 1 byte
的数据并将其转换为 <code>char</code> 类型的函数，且速度很快，故可以用“读入字符—转换为整型”来代替缓慢的读入</p>
<p>每个整数由两部分组成—符号和数字</p>
<p>整数的 '+' 通常是省略的，且不会对后面数字所代表的值产生影响，而 '-'
不可省略，因此要进行判定</p>
<p>10 进制整数中是不含空格或除 0~9
和正负号外的其他字符的，因此在读入不应存在于整数中的字符（通常为空格）时，就可以判定已经读入结束</p>
<p><strong>代码实现</strong><br />
C 和 C++ 语言分别在 ctype.h 和 cctype
头文件中，提供了函数 <code>isdigit</code>,
这个函数会检查传入的参数是否为十进制数字字符，是则返回 <strong>true</strong>，否则返回 <strong>false</strong>。对应的，在下面的代码中，可以使用 <code>isdigit(ch)</code> 代替 <code>ch &gt;= '0' &amp;&amp; ch &lt;= '9'</code>，而可以使用 <code>!isdigit(ch)</code> 代替 <code>ch &lt;'0' || ch&gt; '9'</code></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> w <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>ch <span class="token operator">&lt;</span> <span class="token char">'0'</span> <span class="token operator">||</span> ch <span class="token operator">></span> <span class="token char">'9'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ch 不是数字时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span> w <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 判断是否为负</span>
    ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 继续读入</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>ch <span class="token operator">>=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ch 是数字时</span>
    x <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ch <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将新读入的数字’加’在 x 的后面</span>
    <span class="token comment">// x 是 int 类型，char 类型的 ch 和 ’0’ 会被自动转为其对应的</span>
    <span class="token comment">// ASCII 码，相当于将 ch 转化为对应数字</span>
    <span class="token comment">// 此处也可以使用 (x&lt;&lt;3)+(x&lt;&lt;1) 的写法来代替 x*10</span>
    ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 继续读入</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> x <span class="token operator">*</span> w<span class="token punctuation">;</span>  <span class="token comment">// 数字 * 正负号 = 实际数值</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>读入 num 可写为 <code>num=read();</code></p>
<h5 id="输出优化">输出优化</h5>
<p><strong>原理</strong><br />
同样是众所周知，<code>putchar</code> 是用来输出单个字符的函数，因此将数字的每一位转化为字符输出以加速。要注意的是，负号要单独判断输出，并且每次
%（mod）取出的是数字末位，因此要倒序输出</p>
<p><strong>代码实现</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 判负 + 输出负号 + 变原数为正数</span>
    x <span class="token operator">=</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>
    <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token function">write</span><span class="token punctuation">(</span>x <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 递归，将除最后一位外的其他部分放到递归中输出</span>
  <span class="token function">putchar</span><span class="token punctuation">(</span>x <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 已经输出（递归）完 x 末位前的所有数字，输出末位</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>但是递归实现常数是较大的，我们可以写一个栈来实现这个过程</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> sta<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
    sta<span class="token punctuation">[</span>top<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">,</span> x <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>top<span class="token punctuation">)</span> <span class="token function">putchar</span><span class="token punctuation">(</span>sta<span class="token punctuation">[</span><span class="token operator">--</span>top<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 48 是 '0'</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>输出 num 可写为 <code>write(num);</code></p>
<h3 id="常见信息与错误">常见信息与错误</h3>
<h4 id="compile-error-编译错误">Compile Error: 编译错误</h4>
<p>这类错误多为词法、语法和语义错误，引发的原因较为简单，修复难度较低，比如：</p>
<ul>
<li><code>int main()</code> 写为 <code>int mian()</code> 之类的拼写错误</li>
<li>忘记打分号</li>
</ul>
<h4 id="presentation-error-输出格式错误">Presentation
Error :输出格式错误</h4>
<p>答案正确但没按题目要求输出</p>
<h4 id="wrong-answer-答案错误">Wrong Answer ：答案错误</h4>
<p>输出的答案错误，具体问题各不相同，大概有这几种情况</p>
<ul>
<li>代码哪里写出bug了，代码功能与自己想实现的功能相异。</li>
<li>解题逻辑和思路错误。</li>
<li>特殊情况没有处理，比如0，1，2和最大值这种边界值没有考虑。</li>
<li>空间开的不够大，造成越界，但越界并没有进行修改，或者修改的数据不是关键数据，导致不触发RE，但因为访问或者修改的错误的数据，导致输出结果错误。</li>
</ul>
<h4 id="runtime-error-运行时错误">Runtime Error ：运行时错误</h4>
<p>程序运行到一半，程序就崩溃并异常终止了</p>
<ul>
<li>越界，想从一些非法的地址空间读取或向其中写入内容。
<ul>
<li>数组（下标）越界<br />
例如：
<ul>
<li>未正确设置循环的初值导致访问了下标为 -1 的值。</li>
<li>无向图边表未开 2 倍。</li>
</ul></li>
<li>指针越界： <pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span> p<span class="token punctuation">;</span> 
p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span></code></pre></li>
<li>使用已经释放的空间： <pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span> p<span class="token punctuation">;</span> 
p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span></code></pre></li>
</ul></li>
<li>除0（求 0 的逆元）或模0错误</li>
<li>过多的申请栈内存导致栈溢出，如无限或过多的递归，在main函数中申请空间（此项由于不同OJ设置可能会有出入，有些OJ堆栈内存共享）。</li>
<li>使用STL的非法操作，比如从空stack中取top。</li>
</ul>
<h4 id="segmentation-fault段错误">Segmentation Fault：段错误</h4>
<p>类似Runtime Error。</p>
<ul>
<li>缓冲区溢出，也就是你访问
了非法内存，或者在C/C++中访问了空指针等等。</li>
<li>堆栈溢出（例如数组开得太大，超出了栈的范围）。</li>
</ul>
<h4 id="time-limit-exceeded-时间超限">Time Limit Exceeded :时间超限</h4>
<p>程序运行时间太长了，超过了对应题目的时间限制。</p>
<ul>
<li>代码无限循环。
<ul>
<li>分治未判边界导致死递归。</li>
<li>死循环。</li>
<li>BFS 时不标记某个状态是否已访问过。</li>
</ul></li>
<li>算法复杂度过大。</li>
</ul>
<h4 id="memory-limit-exceeded内存超限">Memory Limit
Exceeded：内存超限</h4>
<p>程序运行所用的内存太多了，超过了对应题目的限制。</p>
<ul>
<li>内存空间申请过大。</li>
<li>在有些oj（cf，洛谷）中，堆栈共享内存空间，这时当你出现过多的递归这种大量的栈内存使用的时候，不会栈溢出导致RE，而是内存超限导致MLE。</li>
<li>STL 容器中插入了过多的元素。
<ul>
<li>经常是在一个会向 STL 插入元素的循环中死循环了。</li>
<li>也有可能被卡了。</li>
</ul></li>
</ul>
<h4 id="会导致未知的结果">会导致未知的结果</h4>
<p>未定义行为会导致未知的结果。</p>
<ul>
<li>使用 <code>scanf</code> 读入的时候没加取地址符 <code>&amp;</code>。</li>
<li>使用 <code>scanf</code> 或 <code>printf</code> 的时候参数类型与格式指定符不符</li>
<li>把 <code>==</code> 写成<code>=</code></li>
<li>不注意运算符的优先顺序和结合性</li>
<li>局部变量未初始化</li>
<li>局部变量与全局变量重名，导致全局变量被意外覆盖</li>
</ul>
<h4 id="会导致常数过大">会导致常数过大</h4>
<ul>
<li>定义模数的时候，未定义为常量。
<ul>
<li>示例： <pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// int mod = 998244353; // 错误      </span>
<span class="token keyword">const</span> <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">998244353</span><span class="token punctuation">;</span>  <span class="token comment">// 正确，方便编译器按常量处理</span></code></pre></li>
</ul></li>
<li>使用了不必要的递归（尾递归不在此列）。</li>
<li>将递归转化成迭代的时候，引入了大量额外运算。</li>
</ul>
<h3 id="常见技巧">常见技巧</h3>
<h4 id="利用宏定义简化代码量">利用宏定义简化代码量</h4>
<p>最简单的例子就是：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span></code></pre>
<h4 id="使用宏进行调试">使用宏进行调试</h4>
<p>编程者在本地测试的时候，往往要加入一些调试语句。而在需要提交到 OJ
时，为了不使调试语句的输出影响到系统对程序输出结果的判断，就要把它们全部删除，耗时较多。这种情况下，可以通过定义宏的方式来节省时间。大致的程序框架是这样的：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEBUG</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span>
<span class="token comment">// do something when DEBUG is defined</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token comment">// or</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">DEBUG</span></span>
<span class="token comment">// do something when DEBUG isn't defined</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre>
<p><code>#ifdef</code> 会检查程序中是否有 <code>#define</code> 定义的对应标识符，如果有定义，就会执行后面的语句。而 <code>#ifndef</code> 会在没有定义相应标识符的情况下执行后面的语句。</p>
<p>这样，只需在 <code>#ifdef DEBUG</code> 里写好调试用代码，<code>#ifndef DEBUG</code> 里写好真正提交的代码，就能方便地进行本地测试。提交程序的时候，只需要将 <code>#define DEBUG</code> 一行注释掉即可。也可以不在程序中定义标识符，而是通过 <code>-DDEBUG</code> 的编译选项在编译的时候定义 <code>DEBUG</code> 标识符。这样就可以在提交的时候不用修改程序了。</p>
<p>不少 OJ
都开启了 <code>-DONLINE_JUDGE</code> 这一编译选项，善用这一特性可以节约不少时间。</p>
<hr />
<p>参考自：<br />
<a href="https://oi-wiki.org/contest/oi/">OI 赛事与赛制</a><br />
<a href="https://oi-wiki.org/contest/common-tricks/">OI-Wiki
常见技巧</a><br />
<a href="https://oi-wiki.org/lang/file-op/">OI-Wiki 文件操作</a><br />
<a href="https://oi-wiki.org/contest/io/">OI-Wiki
读入、输出优化</a><br />
<a href="https://oi-wiki.org/contest/common-mistakes/">OI-Wiki
常见错误</a><br />
<a
href="https://www.cnblogs.com/littlehb/p/15304297.html">C++中数组可以开多大</a><br />
<a href="https://blog.51cto.com/u_15061931/4897317">ACM
OJ常见错误以及解决方法</a><br />
<a href="https://blog.csdn.net/dreambyday/article/details/54880616">VJ
runtime error可能的原因</a><br />
<a
href="https://www.zhihu.com/question/49059234/answer/597104154%3E">如何看待在
OI / ACM 赛事广为使用的快速读入整数？</a></p>
<p><a
href="https://wenku.baidu.com/view/de96a16ee75c3b3567ec102de2bd960591c6d94c?aggId=de96a16ee75c3b3567ec102de2bd960591c6d94c">ACM时间复杂度及算法的选择分析</a><br />
<a href="https://blog.csdn.net/qq_40763929/article/details/86726906">ACM
竞赛 中 时间复杂度分析 及 每种复杂度的最大循环次数</a><br />
<a
href="https://www.cnblogs.com/buhuizhuzhou/p/16186555.html">【上交ACM-算法初级】算法评价与复杂度</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>技巧与思想</tag>
        <tag>NOI暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>~scanf的作用</title>
    <url>/posts/62068.html</url>
    <content><![CDATA[<ul>
<li><strong><code>scanf("%d %d",&amp;a,&amp;b);</code></strong><br />
函数返回值为<code>int</code>型。如果<code>a</code>和<code>b</code>都被成功读入，那么<code>scanf</code>的返回值就是<code>2</code>；<br />
如果只有<code>a</code>被成功读入，返回值为<code>1</code>；<br />
如果<code>a</code>和<code>b</code>都未被成功读入，返回值为<code>0</code>；<br />
如果遇到错误或遇到<code>end of file</code>，返回值为<code>EOF（-1）</code>。</li>
<li><strong><code>~</code></strong><br />
<code>'~'</code>为一元运算符，用于求整数的二进制反码。<br />
<code>scanf()</code>的返回值为大于等于<code>-1</code>的数，只有当<code>scanf()</code>返回值为<code>-1</code>（二进制表示为全<code>1</code>）时，<code>~scanf()</code>的值为<code>0</code>，其他情况均不为<code>0</code>.</li>
<li><strong><code>while</code></strong><br />
<code>while</code>循环只有在条件为假（<code>0</code>）时才跳出循环（条件值为负数仍继续循环）。</li>
</ul>
<p>当输入未遇到错误（<code>scanf()</code>返回值不为<code>0</code>）时，循环会一直继续下去，进而达到控制循环的目的。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">/*~scanf("%d%d",&amp;a,&amp;b)的返回值永不为0*/</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI暑假培训</title>
    <url>/posts/35376.html</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>人都已经回到家中了，受老师之托，奈何这工资太诱人了，加上这生活也很拮据，就决定去上给老师的学生上NOI暑假培训课程。做了一段时候才慢慢的应付自如起来，但是仍有些时候手忙脚乱。很早以前我就在博客园的博文中指出OI的培养和训练体系比ACM要远远完善的多，只是察觉的太晚，早就没了心气和足够的时间。不过当初刚入ACM集训队的时候也察觉到了这点，只是在环境中慢慢被同化了，忽视了自己其实连基础的知识都掌握不牢固，总是追求那些进阶的知识点或者经常比赛又有什么意义呢，做事情还是要踏踏实实落实到最基础的刷题上来。现如今有个机会让我重新回顾下基础性的知识并加以总结，我想也是不错的。</p>
<h2 id="集训内容">集训内容</h2>
<p><strong>1 技巧与思想：</strong><br />
<a href="R%20-%20二分法.md">二分法</a><br />
<a href="R%20-%20贪心法.md">贪心法</a><br />
<a href="R%20-%20排序算法.md">排序算法</a><br />
<a href="R%20-%20递归与递推.md">递归与递推</a><br />
<a href="R%20-%20分治与倍增.md">分治与倍增</a></p>
<p><strong>2 动态规划：</strong><br />
<a href="R%20-%20动态规划—线性DP.md">动态规划—线性DP</a><br />
<a href="R%20-%20动态规划—背包问题.md">动态规划—背包问题</a><br />
<a href="R%20-%20动态规划—区间DP.md">动态规划—区间DP</a></p>
<p><strong>3 数据结构基础：</strong><br />
<a
href="R%20-%20数据结构基础—栈、队列、链表.md">数据结构基础—栈、队列、链表</a><br />
<a href="R%20-%20数据结构基础—树.md">数据结构基础—树</a><br />
<a href="R%20-%20数据结构基础—图.md">数据结构基础—图</a></p>
<p><strong>4 图论</strong><br />
<a href="R%20-%20图论—最短路径.md">图论—最短路径</a><br />
<a href="R%20-%20图论—最小生成树.md">图论—最小生成树</a></p>
<p><strong>5 数学</strong><br />
<a href="R%20-%20高精度计算.md">高精度计算</a><br />
<a href="R%20-%20数论—常见符号.md">数论—常见符号</a><br />
<a href="R%20-%20数论—整除理论.md">数论—整除理论</a><br />
<a href="R%20-%20数论—模运算的世界.md">数论—模运算的世界</a><br />
<a href="R%20-%20数论—组合数学与计数.md">数论—组合数学与计数</a></p>
<p><strong>6 算法评估与比赛事宜</strong><br />
<a href="R%20-%20CSP赛前总结.md">CSP赛前总结</a></p>
<h2 id="集训记录">集训记录</h2>
<p><strong>1 题目集：</strong><br />
<a href="https://vjudge.net/article/2924">2022
NOI暑假集训【普及/提高-】</a><br />
<a
href="https://github.com/sparkyen/algorithm/tree/main/NOI-Competition">2022
NOI暑假集训【普及/提高-】题解代码</a></p>
<p><a
href="../images/NOI暑假培训/2022%20NOI暑假集训【普及_提高-】%20-%20Virtual%20Judge.pdf">本地存档</a><br />
<strong>2 比赛：</strong><br />
<a href="https://vjudge.net/contest/504214">2022
NOI暑假欢乐赛(一)</a><br />
<a href="https://vjudge.net/contest/505437">2022
NOI暑假欢乐赛(二)</a><br />
<a href="https://www.luogu.com.cn/contest/76751#scoreboard">2022
NOI暑假欢乐赛(三)</a></p>
<h2 id="总结">总结</h2>
<p>1
不管是做题搞算法，还是别的事情，有时候需要时间来反应，可能过吃个饭休息下就转过弯来了，弄明白了。</p>
<p>2
教学经历是很宝贵的，我也发现这个过程能帮助我理解自己教学的内容，然给对知识的掌握更深了一步。</p>
<p>3 人是很容易遗忘的，因此需要记录、总结，并时不时进行回顾</p>
<p>最后附上整个暑假集训的思维导图：<br />
<img data-src="../images/NOI暑假培训/NOI暑假集训内容大纲.svg" /></p>
]]></content>
      <categories>
        <category>感想与总结</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/posts/3510.html</url>
    <content><![CDATA[<h1 id="二分查找">二分查找</h1>
<h2 id="整数集合上的二分">整数集合上的二分</h2>
<p>在单调递增序列中查找&gt;=x的数中的最小的一个</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">findUpperId</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>x<span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>
		<span class="token keyword">else</span> l <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> l<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>在单调递增序列中查找&lt;=x的数中的最大的一个</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">findLowerId</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> 
		<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>x<span class="token punctuation">)</span> l <span class="token operator">=</span> mid<span class="token punctuation">;</span>
		<span class="token keyword">else</span> r <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> l<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</code></pre>
<p>如上面两段代码所示，这种二分写法可能会有两种形式:</p>
<ol type="1">
<li>缩小范围时，<code>r = mid，l = mid + 1</code>，取中间值时，<code>mid = (l+ r)/2</code>。</li>
<li>缩小范围时，<code>l = mid，r = mid -1</code>，取中间值时，<code>mid = (l+r+ 1)/2</code>。</li>
</ol>
<p>如果不对<code>mid</code>
的取法加以区分，例如第二段代码假如也采用<code>mid =(l+r)/2</code>,那么当<code>r-l</code>等于1时，就有<code>mid= l(l+r)/2]= l</code>。接下来若进入
<code>l = mid</code>分支,可行区间未缩小,造成死循环;若进入<code>r = mid -1</code>分支,造成<code>l&gt;r</code>,循环不能以<code>l == r</code>结束。例如在数组[1,
2, 4, 7]寻找&lt;=5的中最大的一个数。</p>
<p>因此对两个形式采用配套的<code>mid</code>取法是必要的。上面两段代码所示的两个形式共同组成了这种二分的实现方法。对两个形式采用配套的<code>mid</code>取法是必要的,上面两段代码所示的两个形式共同组成了这种二分的实现方法。</p>
<p>仔细分析这两种<code>mid</code>的取法，我们还发现:<br />
<code>mid=(l+r)/2</code>不会取到r这个值， <code>mid=(l+r+ 1)/2</code> 不会取到l这个值。<br />
<strong>可以利用这一性质来处理无解的情况，把最 初的二分区间<span
class="math inline">\([1,n]\)</span> 分别扩大为<span
class="math inline">\([1,n+1]\)</span> 和<span
class="math inline">\([0,n]\)</span>, 把a数组的一个越界的下标包含进来。如果最后二分终止于扩大后的这个越界下标上,则说明a中不存在所求的数。</strong> 总而言之，正确写出这种二分的流程是: </p>
<ol type="1">
<li>通过分析具体问题，确定左右半段哪一个是可行区间，以及mid归属哪一半段。<br />
</li>
<li>根据分析结果，选择“<code>r=mid, l= mid +1, mid=(l+r)/2</code>"和“<code>I = mid, r= mid-1, mid=(l+r+ 1)/2</code>”两个配套形式之一。<br />
</li>
<li>二分终止条件是<code>l == r</code>，该值就是答案所在位置。</li>
</ol>
<p>使用的这种二分方法的优点是始终保持答案位于二分区间内，二分结束条件对应的值恰好在答案所处位置，还可以很自然地处理无解的情况,形式优美。唯一的缺点是由两种形式共同组成，需要认真考虑实际问题选择对应的形式。</p>
<h2 id="实数域上的二分">实数域上的二分</h2>
<p>需要保留<span
class="math inline">\(k\)</span>位小数时，精度<code>eps</code>一般取<code>eps=10^-(k+2)</code>。但<code>eps</code>不要取得太小，否则会因为浮点小数精度的原因陷入死循环</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token operator">></span><span class="token number">1e-5</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">double</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">cal</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>
	<span class="token keyword">else</span> l <span class="token operator">=</span> mid<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>有时精度不容易确定或表示，就干脆采用循环固定次数的二分方法，也是一种相当不错的策略。这种方法得到的结果的精度通常比设置<code>eps</code>更高。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">double</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">cal</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>
	<span class="token keyword">else</span> l <span class="token operator">=</span> mid<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<h1 id="二分答案转化为判定">二分答案转化为判定</h1>
<p>二分思想不仅可以在有序序列中快速查询元素，还能高效率的解决一些具有单调性判定的问题</p>
<p>先以我们熟悉的二分查找为例来体会一下：给定升序数组<span
class="math inline">\(a[n]\)</span>，需找到<span
class="math inline">\(\geq k\)</span>的最小值。</p>
<p>依据题意，我们就可以将条件设置为：满足<span
class="math inline">\(\geq k\)</span>。假设答案在<span
class="math inline">\([L, R]\)</span>中，若区间中间<span
class="math inline">\(mid\)</span>满足条件，由于求的是满足条件得的最小值，说明还可以向左尝试二分，即答案一定在<span
class="math inline">\([L, mid]\)</span>上，其过程如下图所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/二分查找示意图.png" /></p>
<p>现在从具体问题中抽象出来，假设最优解的评分是<span
class="math inline">\(S\)</span>，显然对于所有<span
class="math inline">\(&gt;S\)</span>的值，都不存在一个合法的方案达到该评分，否则就与<span
class="math inline">\(S\)</span>的最优性矛盾; 而对于所有<span
class="math inline">\(&lt;S\)</span>的值，一定存在一个合法的方案达到或超过该评分，因为最优解就满足这个条件。</p>
<p>这样问题的值域就具有一种特殊的单调性：<br />
在 <span class="math inline">\(S\)</span>的一侧合法、在<span
class="math inline">\(S\)</span>的另一侧不合法，就<strong>像</strong>一个 在<span
class="math inline">\((-\infty,S]\)</span> 上值为1，在<span
class="math inline">\((S,+\infty)\)</span>上值为0的分段函数，可通过二分找到这个分界点 <span
class="math inline">\(S\)</span>。</p>
<p><strong>借助二分，我们把求最优解的问题，转化为给定一个值<span
class="math inline">\(mid\)</span>, 判定是否存在一个可行方案评分达到<span
class="math inline">\(mid\)</span>的问题。</strong></p>
<h3 id="例一">例一</h3>
<blockquote>
<p><span class="math inline">\(n\)</span>颗树高度分别为<span
class="math inline">\(a_1,a_2,...,a_n\)</span>。对于砍树高度<span
class="math inline">\(h\)</span>，可以锯下并收集每棵树上比<span
class="math inline">\(h\)</span>高的部分的木材，现在求最大的整数<span
class="math inline">\(h\)</span>，使得收集到长度为<span
class="math inline">\(m\)</span>的木材</p>
</blockquote>
<p>例如5棵树，需要收集到20单位的木材，高度为[4, 42, 40, 26,
46]，可以将<span class="math inline">\(h\)</span>调整为36，分别锯下[6,
4, 10]的木材。但是锯子再高一点就不能满足要求了。</p>
<p>将h从小往大枚举显然非常耗时，效率低下，可以尝试看能不能使用二分。</p>
<p>我们可以令判定条件为：砍树高度为<span
class="math inline">\(x\)</span>时可以获得不少于<span
class="math inline">\(m\)</span>的木材，那么就变成了要找最大的<span
class="math inline">\(x\)</span>使得"条件"成立。</p>
<p>再来看下这个"条件"是否具有单调性：当<span
class="math inline">\(x\)</span>超过最优解时，"条件"一定不成立；当<span
class="math inline">\(x\)</span>不超过这个数时，"条件"一定成立。如下图所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/二分答案之收集木材示意图.png" /></p>
<p>以上完全符合二分条件，不过二分的取法要特别注意，见<a
href="##整数集合上的二分">mid取法</a>，实现代码如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e6</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
ll n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	ll tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>x<span class="token punctuation">)</span> tot <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">;</span>
	<span class="token keyword">return</span> tot <span class="token operator">>=</span> m<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">1e9</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token comment">//二分的取法要特别注意 </span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> l <span class="token operator">=</span> mid<span class="token punctuation">;</span>
		<span class="token keyword">else</span> r <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">//		cout &lt;&lt; mid &lt;&lt; endl;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</code></pre>
<p><strong>使用二分答案技巧的条件：</strong></p>
<ol type="1">
<li><p>命题可以被归纳为找到某命题P(x)成立(或者不成立)的最大(或最小)的x</p></li>
<li><p>把P(x)看作一个值为真或假的函数，那么它一定要某个分界线的一侧全为真，另一侧全为假</p></li>
<li><p>可以找到一个复杂度复杂的算法来检验P(x)的真假</p></li>
</ol>
<p><strong>通俗来说，二分答案可以用来处理"最大的最小"或"最小的最大"问题</strong></p>
<h3 id="例二">例二</h3>
<p>下面是一个经典的例子。</p>
<blockquote>
<p>有<span class="math inline">\(N\)</span>本书排成一行，已知第<span
class="math inline">\(i\)</span>本书的厚度是<span
class="math inline">\(A_i\)</span>。把他们分成连续的<span
class="math inline">\(M\)</span>组，使<span
class="math inline">\(T\)</span>最小化，其中<span
class="math inline">\(T\)</span>表示厚度之和最大的一组的厚度。</p>
</blockquote>
<p>假设最终答案为<span
class="math inline">\(S\)</span>，如果要求每组的厚度都<span
class="math inline">\(&lt;S\)</span>，那么这<span
class="math inline">\(M\)</span>组一定不能容纳这些书，可能需要更多的组才能把书分完， 也就意味着对于本题的限制条件不存在可行的分书方案。如果每组的厚度可以<span
class="math inline">\(&gt;S\)</span>，那么一定存在一种分书方案使得组数不会超过<span
class="math inline">\(M\)</span>（一定范围内都是可以分为<span
class="math inline">\(M\)</span>组的，只要不是厚度过大）。最优解就处于分书可行性的分界点上，它们之间的关系如下图所示：</p>
<p><img data-src="../images/NOI暑假培训/算法专题/二分判断书籍厚度示意图.png" /></p>
<p>而这里的判定条件就是：当一组书最大厚度为size时，是否能够把书分得的组数不超过M</p>
<pre class="language-c" data-language="c"><code class="language-c">bool <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> group<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>rest<span class="token operator">=</span>size<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>rest<span class="token operator">>=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> rest<span class="token operator">-=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> group<span class="token operator">++</span><span class="token punctuation">,</span>rest<span class="token operator">=</span>size<span class="token operator">-</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> group<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>r<span class="token operator">=</span>sum_of_ai<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token comment">/*
        由于是求最小值因此每次满足条件后让r = mid
        这样能够让求的值尽可能往小的收缩
        */</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> r<span class="token operator">=</span>mid<span class="token punctuation">;</span>
        <span class="token keyword">else</span> l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout<span class="token operator">&lt;&lt;</span>l<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>技巧与思想，二分</tag>
      </tags>
  </entry>
  <entry>
    <title>关于压力和表现的思考</title>
    <url>/posts/52838.html</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>接受了很多年的应试教育，对于该如何考试心里我倒是摸的门清，知道该如何把控考试的紧张、兴奋度，平时该怎么学、最后该预留多少时间复习等等。但是除此以外，别的事情挨到了身上，最终结果并不是每次都那么如意。其中有的只是小小的事情很快就过去了，比如某次上篮没上进下次手再抬高点就可以了，而有的却涉及到个人的幸福和生活之类，是不可逆转的。</p>
<p>面对各类繁琐的事情怎么去做，这是一个慢慢学习的过程，但是我认为同样的重要的是到底该抱着一种怎么样的心态去面对周围的一切。而压力是影响我们心态的因素中很大的一块版图，因此我要在这里谈谈压力对我们表现的影响及其对我们解决问题的指导意义</p>
<h2 id="yerkes-dodson-定律">Yerkes-Dodson 定律</h2>
<p>Yerkes-Dodson 定律是压力和表现之间的经验关系，最初由心理学家Robert M.
Yerkes和John Dillingham Dodson于 1908 年开发。
该定律规定，表现仅在一定程度上会随着生理或精神唤醒而增加
；当唤醒水平变得太高时，表现就会下降。该过程通常以图形方式显示为钟形曲线，随着唤醒水平的提高，该曲线增加然后减少。</p>
<p>研究人员发现，不同的任务需要不同程度的唤醒才能获得最佳表现。例如，困难或智力要求高的任务可能需要较低水平的唤醒（以促进集中），而需要耐力或毅力的任务可能会在较高的唤醒水平下更好地执行（以增加动力）。</p>
<p>由于任务差异，曲线的形状可能会高度可变。对于简单或学习良好的任务，这种关系是单调的，并且随着唤醒的增加，性能会提高。对于复杂的、不熟悉的或困难的任务，在某一点之后，唤醒与绩效之间的关系会发生逆转，之后绩效会随着唤醒的增加而下降。</p>
<p>任务难度的影响导致假设 Yerkes-Dodson
定律可以分解为两个不同的因素，就像浴缸曲线一样。倒 U
形的向上部分可以被认为是唤醒的激励作用。下降部分是由唤醒（或压力）对认知过程（如注意力、记忆力和解决问题的负面影响造成的。<br />
<img data-src="../images/个人感想/765px-OriginalYerkesDodson.svg.png" /></p>
<p>上述结论可以由我们的原始数据得到：<br />
<img data-src="../images/个人感想/547px-OriginalYerkesDodsonData.svg.png" /></p>
<h2 id="其他观点">其他观点</h2>
<p>逆转理论展示心理如何在双稳态而不是稳态原则上运作，以此来积极反对耶克斯-多德森定律。尽管两者在某些方面持有不同观点，当然我也没有仔细研究，不过我仍然觉得他能够给我们带来很多启示。</p>
<p>每个领域都由一对相反的价值观或动机组成，因此在任何给定时刻，每一对中的一个都可以被体验到。域中的每一对代表两种相反形式的动机——每对中一次只能激活一个状态。人类在每对中的状态之间反转取决于许多因素，包括我们采用一种风格而不是另一种风格的固有倾向。</p>
<h3 id="严肃好玩seriousplayful">严肃/好玩(Serious/Playful)</h3>
<p>手段-目的领域中的两种状态被称为“Serious”和“Playful”，指的是一个人是出于成就还是对过程的享受。尽管状态通常以严肃和嬉戏为特征，但在这一领域中最真实的区别在于，一个人是出于长期目标还是出于当前正在发生的事情。未来的成就还是现在的享受？旅程还是目的地？</p>
<h3 id="双稳态">双稳态</h3>
<p>人类总是在寻找一种完美的中等唤醒状态，而任何一个方向都过于极端的想法是不可取的，即无聊或焦虑。</p>
<p>逆转理论提出了一种完全不同的唤醒观点，即所谓的“双稳态”。双稳态强调特征音调中的极性，这由“蝴蝶曲线”图形的曲线表示。它表明唤醒在每个状态下都以不同的方式经历——实际上是相反的方式，并且有自己独特的情绪范围。在用实线表示的严肃（Serious）状态下，这个范围是从放松到焦虑，而在用虚线表示的好玩的Playful）状态下，这个范围是从无聊到兴奋。<br />
<img data-src="../images/个人感想/800px-Reversal_theory_butterfly_curves.png" /></p>
<p>在Serious的状态下，当威胁或要求的事件提高唤醒水平时，一个人会变得焦虑，但在完成一项任务时会愉快地放松。在Playful状态下，一个人变得愉快地兴奋，因为一个人变得更加情绪化和被唤醒，但如果缺乏刺激，就会感到无聊。</p>
<h2 id="心理学理论给我们带来的启示">心理学理论给我们带来的启示</h2>
<p>回过头来看，确实要懂点心理学来指导我们的生活。我们在面对生活中较为简单的事情的时候可以让自己更加兴奋一点，这样通常完成的效率会很高，例如形策报告和练车等等。但是面对一些较为难以实现的目标或者是复杂的事情的时候，可能就需要降低期望，以较为平和的心态来面对，例如学术成就、财富自由等等，这样才会对我们的表现起到较好的影响作用。<strong>当然事物并不是两极性的，不同事情有着不同的最佳动机点，面对越繁杂的任务，就应当越放轻松，以求无为而有所为</strong></p>
<hr />
<p>参考文章:<br />
<a
href="https://en.wikipedia.org/wiki/Yerkes%E2%80%93Dodson_law">耶克斯-多德森定律</a><br />
<a
href="https://en.wikipedia.org/wiki/Reversal_theory#Bistability">逆转理论</a><br />
<a
href="https://www.zhihu.com/question/38347269/answer/76058392">为什么说「太用力的人走不远」？</a><br />
<a
href="https://www.douban.com/group/topic/266061480/?_i=52262078d6f67a0&amp;dt_dapp=1&amp;dt_platform=com.douban.activity.wechat_friends">当你发现没有什么是“一定的”，心态就会很好</a></p>
]]></content>
      <categories>
        <category>感想与总结</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>感想</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>分治与倍增</title>
    <url>/posts/56496.html</url>
    <content><![CDATA[<h1 id="分治">分治</h1>
<p>分治算法的核心思想就是“分而治之”。<br />
大概的流程可以分为三步：<strong>分解 -&gt; 解决 -&gt;
合并</strong>。</p>
<ol type="1">
<li>分解原问题为结构相同的子问题。</li>
<li>分解到某个容易求解的边界之后，进行递归求解。</li>
<li>将子问题的解合并成原问题的解。</li>
</ol>
<p>分治法能解决的问题一般有如下特征：</p>
<ol type="1">
<li>可以把原问题分为多个<strong>无关</strong>的子问题</li>
<li>子问题的答案可以高效合并，即知道了子问题的答案后可以高效计算其对全局答案产生的影响</li>
<li>当前子问题的答案可以高效求出，在这里“高效”的复杂度一般为<span
class="math inline">\(O(n)\)</span>，<span
class="math inline">\(O(nlogn)\)</span></li>
</ol>
<h2 id="归并排序与逆序对">归并排序与逆序对</h2>
<h3 id="归并排序">归并排序</h3>
<p>假设实现归并排序的函数名为 <code>merge_sort</code>。明确该函数的职责，即 <strong>对传入的一个数组排序</strong>。这个问题显然可以分解。给一个数组排序等于给该数组的左右两半分别排序，然后合并成一个数组。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>一个数组<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>可以很容易处理<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">merge_sort</span><span class="token punctuation">(</span>左半个数组<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">merge_sort</span><span class="token punctuation">(</span>右半个数组<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">merge</span><span class="token punctuation">(</span>左半个数组<span class="token punctuation">,</span> 右半个数组<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>具体过程如下图所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/归并排序示例图.png" /></p>
<p>其中<code>merge</code> 函数的实现方式与两个有序链表的合并一致：<br />
<img data-src="../images/NOI暑假培训/算法专题/归并排序归并步骤示例.jpg" /></p>
<p>详细实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归到更小的子问题，即分治 </span>
    <span class="token comment">//归并 </span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
    	<span class="token comment">//后段元素被用完了 或者前段现在的首元素比后段的小 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token operator">||</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token keyword">else</span> tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<h3 id="逆序对">逆序对</h3>
<p>逆序对是<span class="math inline">\(i&lt;j\)</span>且<span
class="math inline">\(a_i&gt;a_j\)</span> 的有序数对<span
class="math inline">\((i,j)\)</span><br />
对于这个问题，可以在归并排序的过程中同时求出序列的逆序对数，操作步骤如下图所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/逆序对示意图.jpg" /><br />
排序后的数组无逆序对，归并排序的合并操作中<strong>每次后段首元素被作为当前最小值取出时，前段剩余元素个数之和</strong>即是合并操作增加的逆序对数量</p>
<p>对此，将 <code>a[j++]</code> 替换为 <code>(cnt += mid+1-i, a[j++])</code> 即可。</p>
<h2 id="快速幂">快速幂</h2>
<p>给出三个整数<span class="math inline">\(b,p,k\)</span>，求<span
class="math inline">\(b^p \ mod \ k\)</span></p>
<p>考虑使用分治来求解：</p>
<ol type="1">
<li>若<span class="math inline">\(p=0\)</span>，答案就是<span
class="math inline">\(b^0 = 1 \ mod \ k\)</span></li>
<li>若<span class="math inline">\(p = 2n\)</span>，即<span
class="math inline">\(p\)</span>是一个偶数，那么可以分解为求<span
class="math inline">\(b^n \ mod \
k\)</span>，最后合并求平方就是答案，即<span class="math inline">\(b^n
\times b^n = b^{2n} = b^p\)</span></li>
<li>若<span class="math inline">\(p = 2n+1\)</span>，即<span
class="math inline">\(p\)</span>是一个奇数，同样可以分解为求<span
class="math inline">\(b^n \ mod \
k\)</span>，最后合并求平方，再乘以b就是答案，即<span
class="math inline">\(b^n \times b^n \times b= b^{2n+1} =
b^p\)</span></li>
</ol>
<p>递归实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll <span class="token function">qpow</span><span class="token punctuation">(</span>ll x<span class="token punctuation">,</span> ll n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">%</span>mod<span class="token punctuation">;</span> <span class="token comment">//这里取模是为了避免k=1的情况出错</span>
	ll tmp <span class="token operator">=</span> <span class="token function">qpow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> tmp<span class="token operator">*</span>tmp<span class="token operator">%</span>mod<span class="token punctuation">;</span>
	<span class="token keyword">return</span>  tmp<span class="token operator">*</span>tmp<span class="token operator">*</span>x<span class="token operator">%</span>mod<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<p>我们可以想到，将<span
class="math inline">\(n\)</span>写成二进制形式就能表示成2的幂次的和，例如<span
class="math inline">\(13 = 1101 = 2^3+2^2+2^0\)</span>，对于<span
class="math inline">\(n\)</span>而言有<br />
<span class="math display">\[n = 2^{k_1}+2^{k_2}+2^{k_3}
\cdots\]</span><br />
就有<br />
<span class="math display">\[x^n = x^{2^{k_1}} \cdot x^{2^{k_2}} \cdot
x^{2^{k_3}} \cdots\]</span></p>
<p>通常快速幂使用非递归的实现方式，代码如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll <span class="token function">qpow</span><span class="token punctuation">(</span>ll x<span class="token punctuation">,</span> ll n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	ll res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> res<span class="token operator">*</span>x<span class="token operator">%</span>mod <span class="token comment">//若二进制最低位为1</span>
		x <span class="token operator">=</span> x<span class="token operator">*</span>x<span class="token operator">%</span>mod<span class="token punctuation">;</span>
		n <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//n二进制表示向后移一位 101101 -> 10110 </span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<h2 id="其他序列上的分治">其他序列上的分治</h2>
<p>给定一个长度为<span class="math inline">\(n\)</span>的序列<span
class="math inline">\(\{a_i\}\)</span>，选出其中连续且非空的一段使得这段和最大</p>
<p>可以把问题分治为：每次将序列从中间分成两半，计算经过中点的最大字段，然后对两边都递归下去计算答案。</p>
<p>其意思为，如果最大子段是跨过中线的，则在这一层统计其答案，如果最大字段没有跨过中线，则对两边递归计算答案的过程会统计其答案。</p>
<p>对于跨过中线的最大字段，可以如下图所示的方式计算：<br />
<img data-src="../images/NOI暑假培训/算法专题/最大字段和示例图.jpg" /></p>
<p>具体实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">maxSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">//分治计算[l, mid]和[mid+1, r] </span>
	<span class="token function">maxSum</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxSum</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pre <span class="token operator">=</span> <span class="token operator">-</span>inf<span class="token punctuation">,</span> suf <span class="token operator">=</span> <span class="token operator">-</span>inf<span class="token punctuation">;</span>
	<span class="token comment">//计算最大的前缀 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid<span class="token punctuation">;</span> i <span class="token operator">>=</span> l<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		tmp <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		pre <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">//计算最大的后缀 </span>
	tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		tmp <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		suf <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>suf<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> pre<span class="token operator">+</span>suf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h1 id="倍增">倍增</h1>
<h2 id="故事背景">故事背景</h2>
<p>从前，有一只可爱得不得了的小白兔，它每天都会醒来都会随机出现在地图某个位置上，并且她酷爱到处旅游撒欢，不过可爱的代价就是她只能向前跳。一天阳光明媚的早晨她醒来发现自己在A地，想去往前方遥远的B、C、D、E、F
......(此处省略超级多个地点)，因为它真的是太没事情做了。显然，小白兔不能知道下一步会到哪里，除非她自己走过去。<br />
<img data-src="../images/NOI暑假培训/算法专题/倍增示例图.jpg" /><br />
<strong>普通小白兔：</strong><br />
一步又一步，生命不息，跳跃不止。<br />
<strong>超级小白兔：</strong><br />
第一步到B，再一步到C，再一步到D，再一步到E，再一步到F，完工。<br />
（她一定厌烦了无止境跳很多步的生活，不想再普通下去了。于是某天晚上拿个本子做小抄，记录好从每个格子跳任意步会到达的地方，然后赶在天亮之前回来。这样以后，不管早上在哪儿醒来，只要是前方想去的地方，看看小抄本一步就到啦）</p>
<blockquote>
<p>普通兔子 = 速度慢，无资源损耗<br />
超级兔子 = 速度快，多资源损耗（不知她的小抄本是否还够用，100个格子她要记录大概5000条信息）</p>
</blockquote>
<p>人不能既要，又想要，但是兔子可以。她想速度尽可能快，并且想要她的小抄本能够抄的下。那可不可以把记录的信息数降到最低呢？当然可以，2B兔子帮你忙，让你用2战胜敌人。</p>
<p>当你只记录任何一个格子跳1、2、4、8、16……步会到达的格子的时候，你有没有发现信息数突然少了好多好多啊！真的少了好多好多啊！100个格子只要500条左右。</p>
<p>在夜深人静的时候，它偷偷出门做小抄，记录下从每个格子跳1、2、4、8……个格子后会到达的格子，然后在太阳出来后，它在众目睽睽之下，开始了表演。</p>
<p><strong>从A出发：</strong><br />
若跳8个格子（超过B了，放弃）<br />
若跳4个格子（超过B了，放弃）<br />
若跳2个格子（没超过B，跳吧）<br />
若跳1个格子（没超过B，跳吧）<br />
<strong>从B出发：</strong><br />
…………</p>
<p><strong>好的，聪明小白兔白天的事情你已经看懂了，且看它晚上是怎么打小抄的吧。</strong></p>
<p>从A出发跳1步到1（记录下来）<br />
从1出发跳1步到2（记录下来）<br />
…………（跳1步的记录完毕）</p>
<p>从A出发跳2步？就是从A出发跳1步再跳1步的到的地方，翻看小抄，直接誊写从1出发跳1步会到的2这个格子作为A跳2步会到的格子。<br />
从1出发跳2步？跟刚才一样，直接誊写。<br />
…………（跳2步的记录完毕）</p>
<p>从A出发跳4步？你还真去跳4步？不，它也就是等于从A出发跳2步到的2号点再跳2步会到的格子，那么我们直接誊写2号格子跳2步会到的格子就可以了。</p>
<p>……</p>
<p><strong><em>上述操作能够奏效是因为由于十进制数可以表示成2的幂次的和。想要通过若干次求和得出这个数，为寻求最少的步数，我们当然优先选择幂次大的，然后依次小的进行拼凑</em></strong></p>
<p><strong><code>总结感悟</code></strong><br />
类似于前缀和的空间换时间，这里不像超极小白兔一样占用很多的空间，也不像普通小白兔一样时间很长，它达到了空间和时间的平衡</p>
<h2 id="区间最值问题与st表">区间最值问题与ST表</h2>
<p>区间最值问题(Range Maximum/Minimum Query)指的是：给出<span
class="math inline">\(n\)</span>个数<span
class="math inline">\(\{a_i\}\)</span>，并快速查询某个区间的的最值</p>
<p>根据故事背景我们受到启发，同样的预处理以每一个位置开头，长度为<span
class="math inline">\(2^0,2^1,2^2,...,2^{\lfloor log_2 n \rfloor
}\)</span>的所有区间最值。</p>
<p>具体的，令 <span class="math inline">\(f(i,j)\)</span> 表示区间 <span
class="math inline">\([i,i+2^j-1]\)</span>
的最大值。第二维就相当于倍增的时候“跳了 <span
class="math inline">\(2^j-1\)</span> 步”，很容易得出递推式为：<span
class="math inline">\(f(i,j)=\max(f(i,j-1),f(i+2^{j-1},j-1))\)</span>。这样得出来的信息表我们称作ST表(Sparse-Table)。<br />
<img data-src="../images/NOI暑假培训/算法专题/ST表预处理.svg" /></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span><span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<p>而对于查询，假设区间为<span class="math inline">\([l,
r]\)</span>，可以有不同的实现思路：</p>
<ol type="1">
<li><p>区间拆分查询<br />
记区间长度<span
class="math inline">\(L\)</span>，则该区间可以拆分为<span
class="math inline">\(O(log_2L)\)</span>的小区间。将<span
class="math inline">\(L\)</span>二进制拆分，我们可以像故事中的小兔子一样，从<span
class="math inline">\(l\)</span>开始向后跳，每次跳的时候拆出来一个二的幂个数，就可以拼出整个区间
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">RMQ</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> L <span class="token operator">=</span> r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token operator">-</span>inf<span class="token punctuation">;</span>
	<span class="token comment">//表示从i开始走2^j步 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> L<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			i <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></p></li>
<li><p>区间合并查询<br />
对于查询区间最值问题来说，区间合并的过程是允许重叠的，重叠并不会对区间最大值产生影响，因此只要找到两个区间并集为<span
class="math inline">\([l,
r]\)</span>就可以了。为简单起见，我们将两个区间长度都定为<span
class="math inline">\(2^k\)</span>，并令<span
class="math inline">\(k\)</span>为满足<span class="math inline">\(2^k
\leq r-l+1\)</span>的最大整数即可。</p>
<p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">RMQ</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> k <span class="token operator">=</span> log_2<span class="token punctuation">[</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>k<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span> </code></pre></p></li>
</ol>
<p>明显的，区间<span
class="math inline">\([l,l+2^k-1]\)</span>和区间<span
class="math inline">\([r-2^k+1,
r]\)</span>合并起来覆盖了需要查询的区间<span
class="math inline">\([l,r]\)</span>，具体例子如下图所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/ST表查询.svg" /></p>
<p><strong><code>注意</code></strong><br />
<code>&lt;&lt;</code>运算符优先级<strong>小于</strong><code>+-</code>运算符<br />
比如这个表达式：5 - 1 &lt;&lt; 2是多少？<br />
答案是：4 * 2 * 2 = 16。所以我们要写成5 - (1 &lt;&lt; 2)才是5-1 * 2 * 2
= 1</p>
<h3 id="st-表维护其他信息">ST 表维护其他信息</h3>
<p>RMQ很典型的一个特征就是它是一个“可重复贡献问题”，那什么是可重复贡献问题呢？</p>
<blockquote>
<p><strong>可重复贡献问题</strong> 是指对于运算 <span
class="math inline">\(\operatorname{opt}\)</span>，满足 <span
class="math inline">\(x\operatorname{opt}
x=x\)</span>，则对应的区间询问就是一个可重复贡献问题。例如，最大值有
<span class="math inline">\(\max(x,x)=x\)</span>，gcd 有 <span
class="math inline">\(\operatorname{gcd}(x,x)=x\)</span>，所以 RMQ
和区间 GCD
就是一个可重复贡献问题。像区间和就不具有这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次，这是我们所不愿意看到的。另外，<span
class="math inline">\(\operatorname{opt}\)</span>
还必须满足结合律（运算的顺序并不会影响到表示式的值）才能使用 ST
表求解。</p>
</blockquote>
<p>除 RMQ
以外，还有其它的“可重复贡献问题”。例如“区间按位和”、“区间按位或”、“区间
GCD”，ST 表都能高效地解决。</p>
<h2 id="总结">总结</h2>
<p>ST
表能较好的维护“可重复贡献”的区间信息（同时也应满足结合律），时间复杂度较低，代码量相对其他算法很小。但是，ST
表能维护的信息非常有限，不支持修改操作</p>
<h1 id="练习巩固">练习巩固</h1>
<p><a
href="https://www.luogu.com.cn/problem/P1908">【归并排序与逆序对】洛谷-P1908
逆序对</a><br />
<a href="https://www.luogu.com.cn/problem/P1226">【快速幂】洛谷-P1226
【模板】快速幂取余运算</a><br />
<a
href="https://www.luogu.com.cn/problem/P1115">【其他序列上的分治】洛谷-P1115
最大子段和</a><br />
<a
href="https://www.luogu.com.cn/problem/P2880">【RMQ问题ST表解法】洛谷-P2880
[USACO07JAN] Balanced Lineup G</a></p>
<hr />
<p>参考自：<br />
《挑战程序设计竞赛》<br />
《深入浅出程序设计竞赛—进阶篇》<br />
<a href="https://oi-wiki.org/basic/divide-and-conquer/">OI-Wiki
递归&amp;分治</a><br />
<a
href="https://blog.csdn.net/JarjingX/article/details/8180560">【白话系列】倍增算法</a><br />
<a href="https://oi-wiki.org/ds/sparse-table/">OI-Wiki ST表</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>技巧与思想</tag>
        <tag>NOI暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划—区间DP</title>
    <url>/posts/13045.html</url>
    <content><![CDATA[<p>区间类动态规划是线性动态规划的扩展，其中一个状态往往由若干个比它更小且包含它的区间的状态转移而来。</p>
<ul>
<li><strong>特征</strong>：能将问题分解为能两两合并的形式，能将两个或多个部分进行整合。</li>
<li><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</li>
</ul>
<p>这里以<a href="https://www.luogu.com.cn/problem/P1775">洛谷-P1775
石子合并（弱化版）</a> 为例说明，根据题意可以将<span
class="math inline">\(f[i][j]\)</span>表示为把第<span
class="math inline">\(i\)</span>堆到第<span
class="math inline">\(j\)</span>堆的石头合并为一堆的最优值，求出<span
class="math inline">\(f[1][n]\)</span>即为答案。将第<span
class="math inline">\(i\)</span>堆到第<span
class="math inline">\(j\)</span>堆的石头合并为一堆前，必然会有这样的一个过程：<strong>将区间左边的合为一堆、区间右边合为一堆，最后再将左右两堆合为一堆</strong>。因此区间长度更长的信息一定由区间长度更短的信息转移得到，因此我们需要将区间短的信息先求出来，之后通过中间的划分点来枚举转移的最优值。最后需要注意递推边界的初始化：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">memset</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//INF</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//初始化 </span>
<span class="token punctuation">&#125;</span> 
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> l<span class="token operator">+</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//状态: 左端点 </span>
		<span class="token keyword">int</span> r <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//状态: 右端点 </span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//决策 </span>
			f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">+=</span> sum<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>sum<span class="token punctuation">[</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>假设这里石头并不是一条链而是围成一个圆环，那么这时将这些石子合并的最优值该怎么求解呢？</p>
<p>我们将这条链延长两倍，变成<span
class="math inline">\(2*n\)</span>堆，这样就能枚举到所有将环分开成链的位置，如下所示：</p>
<p><span class="math display">\[1 \quad 2\quad 3\quad 4 \quad ... \quad
n \quad 1 \quad 2\quad 3 \quad 4 \quad .... \quad n\]</span><br />
求解后取<span class="math inline">\(f(1,n), f(2, n+1), ..., f(n,
n+n-1)\)</span>中的最优值，即为最后的答案。这里以<a
href="https://www.luogu.com.cn/problem/P1880">洛谷-P1880 [NOI1995]
石子合并</a>说明：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">110</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>n<span class="token operator">?</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> minRes <span class="token operator">=</span> inf<span class="token punctuation">,</span> maxRes <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> l<span class="token operator">+</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;=</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
			<span class="token keyword">int</span> r <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  
			<span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">>=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>l<span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> 
				g<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span>l<span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> 
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				g<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>g<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>		
			f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">+=</span> sum<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>sum<span class="token punctuation">[</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			g<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">+=</span> sum<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>sum<span class="token punctuation">[</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">==</span>n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				minRes <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minRes<span class="token punctuation">,</span> f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				maxRes <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxRes<span class="token punctuation">,</span> g<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n%d"</span><span class="token punctuation">,</span> minRes<span class="token punctuation">,</span> maxRes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<p>将以上内容弄清楚后，可以以<a
href="https://www.luogu.com.cn/problem/P1063">洛谷-P1063 [NOIP2006
提高组]
能量项链</a>为练习试试看自己是否掌握，这题需要注意合并价值的计算方法即可：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">110</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		a<span class="token punctuation">[</span>i<span class="token operator">+</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>	
	<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> l<span class="token operator">+</span>len<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> r <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
				f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">*</span>a<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>a<span class="token punctuation">[</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">==</span>n<span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<hr />
<p>参考自:<br />
<a href="https://oi-wiki.org/dp/interval/">区间 DP</a><br />
《信息学奥赛一本通》<br />
《算法竞赛进阶指南》</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划—线性DP</title>
    <url>/posts/52610.html</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>尽管动态规划有很多概念，比如后效性什么的，但是我并不习惯于去细扣并且证明那么东西。相反，动态规划在我眼里和递推没有什么区别，有点类似于数学归纳法：首先说明很简单的初始条件下成立，然后能由中间的状态证明下一步也是正确的，最后就能证明这个解法是正确的。</p>
<p>因此，动态规划不是一种特殊的算法，而只是解决问题的一种思路，不同的问题需要建立不同的模型去求解，接下来在一些专题中会介绍一些不同的经典模型来帮助你打开思路，了解如何使用动态规划这种思想来求解题目。</p>
<p>求解动态规划类型的题目分三步走：</p>
<ol type="1">
<li>定义你想要的状态，比如斐波拉契数列里面<span
class="math inline">\(f[i]\)</span>就代表当前第<span
class="math inline">\(i\)</span>个斐波拉契数列的值</li>
<li>找递推关系</li>
<li>找递推边界</li>
</ol>
<p>你会发现这个和递推没有什么本质区别</p>
<h2 id="线性动态规划">线性动态规划</h2>
<p>顾名思义，线性<span
class="math inline">\(DP\)</span>就是在一条线上进行<span
class="math inline">\(DP\)</span>，这里举一些典型的例子。</p>
<h3 id="最长上升子序列">最长上升子序列</h3>
<p>给定一个长度为<span class="math inline">\(n\)</span>的数列<span
class="math inline">\(a\)</span>，求数值单调递增的子序列的长度最长是多少</p>
<p>我们用<span class="math inline">\(f[i]\)</span>表示以<span
class="math inline">\(a[i]\)</span>结尾的最长上升子序列长度，可以得出递推关系为：<span
class="math display">\[f[i] =  max(f[i], f[j]+1)  \qquad
a_j&lt;a_i\]</span></p>
<p>容易发现递推的边界，初始时 <span
class="math inline">\(f[i]=1\)</span></p>
<p>若要打印路径，往回走并记录答案即可，以下是具体实现</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e5</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> ans<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> res<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">//记录其中一种解决方案,正着记录，倒着输出</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			res<span class="token punctuation">[</span>id<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			ans<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> id<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
				dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> 
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="最长公共子序列">最长公共子序列</h3>
<p>给定长度分别为<span class="math inline">\(n\)</span>和<span
class="math inline">\(m\)</span>的数列<span
class="math inline">\(a\)</span>和数列<span
class="math inline">\(b\)</span>，求既是<span
class="math inline">\(a\)</span>又是<span
class="math inline">\(b\)</span>的子序列的长度最长的子序列</p>
<p>我们可以用<span
class="math inline">\(dp[i][j]\)</span>来表示第一个串的前<span
class="math inline">\(i\)</span>位，第二个串的前<span
class="math inline">\(j\)</span>位的LCS的长度，那么我们是很容易想到状态转移方程的：</p>
<p>如果当前的<span class="math inline">\(a[i]\)</span>和<span
class="math inline">\(b[j]\)</span>相同（即是有新的公共元素） 那么<br />
<span
class="math display">\[dp[i][j]=max(dp[i][j],dp[i−1][j−1]+1)\]</span><br />
如果不相同，即无法更新公共元素，考虑继承：<br />
<span
class="math display">\[dp[i][j]=max(dp[i−1][j],dp[i][j−1]\]</span></p>
<p>输出方案同理，往回走记录答案即可，以下是具体实现</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s%s"</span><span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>b<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//有新的公共元素则考虑 </span>
			<span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//否则考虑继承</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token comment">//	printf("%d\n", dp[n][m]);</span>
	<span class="token keyword">int</span> pos <span class="token operator">=</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">&amp;&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">==</span>b<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			path<span class="token punctuation">[</span>pos<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
			n<span class="token operator">--</span><span class="token punctuation">,</span> m<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">></span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> n<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> m<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> path<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="数字三角形">数字三角形</h3>
<p>给定一个共有n行的三角矩阵a，其中第i行有i列。从左上角出发，每次可以向下方或者右下方走一步，最终到达底部。求把经过的所有位置上的数加起来，和最大是多少。</p>
<p>用<span class="math inline">\(dp[i][j]\)</span>表示从顶部走到第<span
class="math inline">\(i\)</span>行第<span
class="math inline">\(j\)</span>列，和最大是多少。根据题意很容易就能得出当前的状态可以由左上方和正上方走下来：<br />
<span class="math display">\[  
dp[i][j] = a[i][j]+max(dp[i-1][j-1], dp[i-1][j])  
\]</span></p>
<p>实现代码如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>n<span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span> 
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="编辑距离">编辑距离</h3>
<p>将一个字符串 <span
class="math inline">\(a\)</span> 编辑为另一个字符串 <span
class="math inline">\(b\)</span> 。允许三种编辑动作：删除一个字符、替换一个字符
和 插入一个字符，求需要的最少的编辑步数。</p>
<p>将<span class="math inline">\(f[i][j]\)</span> 表示为：将字符串 <span
class="math inline">\(a\)</span> 前<span
class="math inline">\(i\)</span>位组成的子串编辑为 <span
class="math inline">\(b\)</span>前<span
class="math inline">\(j\)</span>位组成的子串的最少编辑步数。</p>
<p>现有<span class="math inline">\(a\)</span>的子串<span
class="math inline">\(a(i)\)</span>，<span
class="math inline">\(b\)</span>的子串<span
class="math inline">\(b(j)\)</span>:</p>
<ol type="1">
<li>在<span
class="math inline">\(a\)</span>的子串末尾删除一个字符，后进行<span
class="math inline">\(f(i-1,j)\)</span>操作</li>
<li>在<span
class="math inline">\(b\)</span>的子串末尾删除一个字符，后进行<span
class="math inline">\(f(i,j-1)\)</span>操作</li>
<li>把<span class="math inline">\(a\)</span>的字串末尾的字符替换<span
class="math inline">\(b\)</span>末尾的，后进行<span
class="math inline">\(f(i-1,j-1)\)</span>操作</li>
</ol>
<p>他们耗费的操作都是一步，于是<br />
<span class="math display">\[  
dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1  
\]</span></p>
<p>当然若本身<span class="math inline">\(a(i)\)</span>的末尾和<span
class="math inline">\(b(j)\)</span>末尾相同，当前则不必进行任何操作：<br />
<span class="math display">\[  
dp[i][j] = dp[i-1][j-1]  
\]</span></p>
<p>得到具体实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s%s"</span><span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>b<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> 
<span class="token comment">//			cout &lt;&lt; dp[i][j] &lt;&lt; " ";</span>
		<span class="token punctuation">&#125;</span>
<span class="token comment">//		cout &lt;&lt; endl;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<hr />
<p>参考自：<br />
<a
href="https://www.luogu.com.cn/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie">Junior
Dynamic Programming——动态规划初步·各种子序列问题</a><br />
<a href="https://www.luogu.com.cn/problem/solution/P1439">洛谷-P1439
【模板】最长公共子序列 题解</a><br />
vjudge 他人的提交方案<br />
<a href="https://blog.lihj.me/post/latex-equation-expression.html">Latex
方程式序列与条件表达式</a><br />
<a
href="https://writings.sh/post/algorithm-minimum-edit-distance">最短编辑距离问题
- 动态规划方法及打印</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划—背包问题</title>
    <url>/posts/58047.html</url>
    <content><![CDATA[<h2 id="背包">01背包</h2>
<p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放</p>
<p>我们可以将<span class="math inline">\(f(i, j)\)</span>表示把<span
class="math inline">\(1,2,...,i\)</span>个物品装到容量为<span
class="math inline">\(j\)</span>的背包的最大总重量,答案是<span
class="math inline">\(d[n][m]\)</span>，解释如下：</p>
<p><strong>只考虑第 <span
class="math inline">\(i\)</span>件物品的策略（放或不放）</strong>，那么就可以转化为一个只和前
<span class="math inline">\(i−1\)</span> 件物品相关 的问题。</p>
<p>如果不放第<span
class="math inline">\(i\)</span>件物品，那么问题就转化为“前 <span
class="math inline">\(i−1\)</span> 件物品放入容量为 <span
class="math inline">\(j\)</span> 的背 包中”，价值为 <span
class="math inline">\(f[i−1,j]\)</span>。可以这样思考的原因在于我本来第<span
class="math inline">\(i\)</span>件物品就不放，那么把前<span
class="math inline">\(i\)</span>件物品放入容量为<span
class="math inline">\(j\)</span>的背包里和把前<span
class="math inline">\(i-1\)</span>件物品放入容量为<span
class="math inline">\(j\)</span>的背包里本质是一回事，所以前者状态可以由后者转移得到。</p>
<p>如果放第 <span class="math inline">\(i\)</span>
件物品，那么问题就转化为“前<span class="math inline">\(i−1\)</span>
件物品放 入剩下的容量为<span class="math inline">\(j-w[i]\)</span>
的背包中”, 价值为<span
class="math inline">\(f[i-1][j-w[i]]+v[i]\)</span>，原因同理。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 1-1-1</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//许边读边读入计算而不必保存 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第i件物品放不进去</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>w<span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span></code></pre>
<p>我们还可以将<span class="math inline">\(f(i, j)\)</span>表示把<span
class="math inline">\(i,i+1,...,n\)</span>个物品装到容量为<span
class="math inline">\(j\)</span>的背包的最大总重量,答案是<span
class="math inline">\(d[1][m]\)</span></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 1-1-2</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">==</span>n<span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span>d<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span></code></pre>
<h3 id="空间优化">空间优化</h3>
<p>可以使用滚动数组优化空间，但是导致只有最后一个阶段的状态值，不好打印解。不过就算是二维数组仍然不能保证是最小字典序的解（字典序是从前往后的），因为是逆向打印。</p>
<p>需特别注意的是递推过程种要倒着遍历保证当前为<span
class="math inline">\(i\)</span>时<span
class="math inline">\(f[j]\)</span>都是<span
class="math inline">\(f[i-1][j]\)</span></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 1-1-3</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//需要倒着遍历保证当前为i时f[j]都是f[i-1][j] </span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>v<span class="token punctuation">)</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span></code></pre>
<h3 id="输出方案">输出方案</h3>
<p>记录路径有两种方式，一是根据结果逆推得出，二是在递推的求解过程中就记录下来。这里以<a
href="https://vjudge.net/problem/UVA-624">UVA-624 CD</a>
为例题来说明：</p>
<ol type="1">
<li><p>由dp结果往回逆推 <pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 1-2-1</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//逆推得出</span>
<span class="token keyword">int</span> c <span class="token operator">=</span> m<span class="token punctuation">,</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		res<span class="token punctuation">[</span>id<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		c <span class="token operator">-=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> id<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum:%d\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></p></li>
<li><p>递推求解过程中记录 <pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 1-2-2</span>
<span class="token comment">//初始化 </span>
<span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token comment">/*
		对于测试样例 45 8 4 10 44 43 12 9 8 2
		取>=的结果：4 10 12 9 8 2 sum:45
		取>的结果：43 2 sum:45
		只有取>=才能保证字典序最小 
		*/</span> 
		<span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//记录路径</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		j <span class="token operator">-=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum:"</span> <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre></p></li>
</ol>
<h3 id="输出最小字典序的路径">输出最小字典序的路径</h3>
<ol type="1">
<li>需要将<span class="math inline">\(f(i, j)\)</span>表示把<span
class="math inline">\(i,i+1,...,n\)</span>个物品装到容量为<span
class="math inline">\(j\)</span>的背包的最大总重量。由于<span
class="math inline">\(f(i, \square )\)</span>是由<span
class="math inline">\(f(i+1, \square
)\)</span>转移的来，这样打印解的时候需要从前往后，碰到符合条件的物品直接装入包中，符合最小字典序的定义</li>
<li>保证只要能够选取当前物品<span
class="math inline">\(i\)</span>就尽可能选取，如上方UVA-624 CD 代码 code
1-2-2注释所示。由于后向前递推，这样能保证选取到序号靠前的物品</li>
</ol>
<p>可以自行在<a
href="https://www.acwing.com/problem/content/description/12/">AcWing-12
背包问题求具体方案</a>进行测试，限定条件更多情况下的最优解则需要在递推求解过程中记录，而不能由dp结果往回逆推，因为这样只能保证字典序最小而无法对其他限定条件进行处理，以<a
href="https://vjudge.net/problem/HDU-6083">HDU-6083
度度熊的午饭时光</a>为例说明：</p>
<p><strong>题目要求优先级：价值总和(大) &gt; 序列总和(小) &gt;
字典序(小)</strong><br />
<span
class="math inline">\(dp[j-w[i]]+v[i]&gt;dp[j]\)</span>保证价值总和大的物品被选，相同时<span
class="math inline">\(sum[j-w[i]]+i&lt;sum[j]\)</span>保证序列总和小的物品被选（这里<span
class="math inline">\(sum[i][j]\)</span>表示<span
class="math inline">\(i,i+1,...,n\)</span>个物品装到容量为<span
class="math inline">\(j\)</span>的背包序列和，可以节省空间变为<span
class="math inline">\(sum[j]\)</span>），第二关键字相同时<span
class="math inline">\(sum[j-w[i]]+i==sum[j]\)</span>保证字典序最小</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 1-3-1</span>
<span class="token comment">//ref: #22475787 | yfsyfs's solution for [HDU-6083] (https://vjudge.net/solution/snapshot/22475787)</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//初始化 </span>
<span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//第一关键字 </span>
			dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			sum<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">;</span>
			path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//第一关键字相同 </span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token operator">&lt;=</span>sum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//比较第二关键字 </span>
				sum<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">;</span>
				path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">,</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		res<span class="token punctuation">[</span>id<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		j <span class="token operator">-=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Case #%d:\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> id<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> i<span class="token operator">!=</span>id<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span><span class="token char">' '</span><span class="token operator">:</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="求方案总数">求方案总数</h3>
<p>状态转移方程已经考察了所有可能的背包组成方案，利用如下递推式即可：<br />
<span class="math display">\[f[i][j] = f[i − 1][j]+ f[i-1][j
−v[i]]\]</span></p>
<p>这里以<a href="https://www.acwing.com/problem/content/11/">AcWing-11
背包问题求方案数</a>说明：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// code 1-4-1</span>
<span class="token comment">// ref: https://www.acwing.com/solution/content/11494/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">,</span> mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
<span class="token keyword">int</span> f<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> g<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//把0个物品放入容量为j的背包里，初始化方案数为1</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> w<span class="token punctuation">,</span> v<span class="token punctuation">;</span>
        cin <span class="token operator">>></span> w <span class="token operator">>></span> v<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> w<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                g<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//sitution1.选择第i个物品 </span>
                f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">)</span> g<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>g<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>g<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span> <span class="token comment">//sitution 2选择+不选择 第i个物品 </span>
			<span class="token comment">//sitution 3不选择第i个物品 (g[i][j]=g[i-1][j]) </span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    cout<span class="token operator">&lt;&lt;</span> g<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="完全背包">完全背包</h2>
<p>这里和01背包的区别就在于每件物品有无数件可用，最朴素的解法就是我可以循环遍历看看我用几件物品才能使得当前价值最大，但显然其时间复杂度非常高：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 2-1-1</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">*</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>j<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token operator">*</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>k<span class="token operator">*</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>而我们通过仔细观察发现：01背包中<span
class="math inline">\(f[i][j]\)</span>由 <span
class="math inline">\(f[i-1][j]\)</span>和<span
class="math inline">\(f[i-1][j-w[i]]\)</span> 递推而来是为了保证第<span
class="math inline">\(i\)</span>件物品只选一次而现在第<span
class="math inline">\(i\)</span>件物品可以选无限件
，正好需要可能已经选入第<span
class="math inline">\(i\)</span>件物品的<span
class="math inline">\(f[i][j-w[i]]\)</span></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 2-1-2</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<p>同理这里也<strong>可以使用滚动数组优化，只是需要注意代码与01背包问题的伪代码只有<span
class="math inline">\(j\)</span>的循环次序不同而已</strong>。01背包问题中要按照<span
class="math inline">\(j=m..0\)</span>的逆序来循环，是为了保证第<span
class="math inline">\(i\)</span>次循环中的状态<span
class="math inline">\(f[i][j]\)</span>是由状态<span
class="math inline">\(f[i-1][j-w[i]]\)</span>递推而来。其中为了确保每件物品只选一次,在考虑“选入第<span
class="math inline">\(i\)</span>件物品”这件策略时依据的是一个绝无已经选入第<span
class="math inline">\(i\)</span>件物品的子结果<span
class="math inline">\(f[i-1][j-w[i]\)</span>。而现在完全背包的特点恰是每种物品可选无限件,所以在考虑“加选一件第<span
class="math inline">\(i\)</span>种物品”这种策略时,却正需要一个可能已选入第<span
class="math inline">\(i\)</span>种物品的子结果<span
class="math inline">\(f[i][v一w[i]]\)</span>，所以就可以并且必须采用<span
class="math inline">\(j=0..m\)</span>的顺序循环。这就是这个简单的程序为何成立的道理：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 2-1-3</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>完全背包可以<a
href="https://vjudge.net/problem/51Nod-2649/origin">51Nod-2649
完全背包</a>为例题来练手，不同的解法时间复杂度不同，如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 2-2-1</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//solution 1: TLE</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">*</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
			f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token operator">*</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>k<span class="token operator">*</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//solution 2: AC_78ms</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//solution 3: AC_31ms</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2 id="多重背包">多重背包</h2>
<p>多重背包与完全背包的区别在于进一步限定了每件物品可以选择的数量，这里以<a
href="https://vjudge.net/problem/51Nod-1086/origin">51Nod-1086 背包问题
V2</a>为例题来说明。</p>
<p>同样的我们可以选择和完全背包一样的朴素做法，枚举第<span
class="math inline">\(i\)</span>件物品选择多少件能够使得当前总价值最大：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 3-1-1</span>
<span class="token comment">/*
多重背包朴素做法 AC: 593ms
但是需要输入后 再利用数据进行递推, 否则边输入边运算会超时, 非常的玄学 
*/</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">5e4</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token comment">//weight, value, count</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> w<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">&lt;=</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>k<span class="token operator">*</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
				dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token operator">*</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>k<span class="token operator">*</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="二进制拆分优化">二进制拆分优化</h3>
<p>细心观察发现，朴素做法是把每件物品拆成了<span
class="math inline">\(c[i]\)</span>件，这样的目的是为了枚举取物品的所有可能方案。而我们知道一个十进制整数能被若干个2的整数次幂相加得到，如<span
class="math inline">\(2^0, 2^1, 2^2, ...,2^{k-1},
c[i]-2^k+1\)</span>得到，在此证明略。</p>
<p>因此通过这种形式我们同样能够枚举出取第<span
class="math inline">\(i\)</span>件物品的所有可能方案，枚举次数由<span
class="math inline">\(O(n)\)</span>降至<span class="math inline">\(O(log
\
n)\)</span>。具体做法是将每件物品最大可用数量拆分后，每段单独作为一个新物品，后面的写法则和01背包相同。</p>
<p>每段单独作为一个新物品后，若仍然使用二维数组计算的话，那么第一维的物品数会增加很多，甚至超出内存，严重时无法用于问题求解：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 3-2-1</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">5e4</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token comment">//weight, value, count 由于n*log2(k)大概有800多则只开110的空间不够 </span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> w<span class="token punctuation">[</span><span class="token number">800</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">800</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//这里开800直接MLE爆空间了, 往小了会TLE而不是WA  </span>
<span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">800</span><span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> tw<span class="token punctuation">,</span> tv<span class="token punctuation">,</span> tc<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tw<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tc<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//将原来的n*k组拆为n*log2(k)组 </span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">&lt;</span>tc<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token operator">*</span>tw<span class="token punctuation">,</span> v<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token operator">*</span>tv<span class="token punctuation">;</span>
			tc <span class="token operator">-=</span> k<span class="token punctuation">,</span> k <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> tc<span class="token operator">*</span>tw<span class="token punctuation">,</span> v<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tc<span class="token operator">*</span>tv<span class="token punctuation">;</span> 
	<span class="token punctuation">&#125;</span>	
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> cnt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token punctuation">&#125;</span></code></pre>
<p>在这种情况下，我们必须使用滚动数组来对空间进行优化：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 3-2-2</span>
<span class="token comment">/*
多重背包二进制优化 AC: 46ms
需要注意二进制分组后的数据范围 
*/</span> 
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">5e4</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token comment">//weight, value, count 由于n*log2(k)大概有800多则只开110的空间不够 </span>
<span class="token comment">// 并且空间开小后显示TLE而不是WA </span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> w<span class="token punctuation">[</span><span class="token number">800</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">800</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> f<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> tw<span class="token punctuation">,</span> tv<span class="token punctuation">,</span> tc<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tw<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tc<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//将原来的n*k组拆为n*log2(k)组 </span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">&lt;</span>tc<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token operator">*</span>tw<span class="token punctuation">,</span> v<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token operator">*</span>tv<span class="token punctuation">;</span>
			tc <span class="token operator">-=</span> k<span class="token punctuation">,</span> k <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">//也可以这样写 </span>
<span class="token comment">//		for(int j = 1; j &lt; tc; j &lt;&lt;= 1)&#123;</span>
<span class="token comment">//			w[cnt] = j*tw, v[cnt] = j*tv;</span>
<span class="token comment">//			cnt++, tc -= j;</span>
<span class="token comment">//		&#125;</span>
		w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> tc<span class="token operator">*</span>tw<span class="token punctuation">,</span> v<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tc<span class="token operator">*</span>tv<span class="token punctuation">;</span> 
	<span class="token punctuation">&#125;</span>	
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> cnt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
			f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="使用混合背包求解">使用混合背包求解</h3>
<p>在多重背包中，虽然限制了物品的数量，但是如果数量 * 重量 &gt;=
总重量，则可以考虑完全背包；否则二进制拆分考虑01背包的做法。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 3-3-1</span>
<span class="token comment">/*
混合背包做法   ref: https://www.cnblogs.com/Draymonder/p/7358254.html
AC: 46ms / 边输入边有时候处理 78ms (玄学)
*/</span> 
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
<span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">50100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    	<span class="token keyword">int</span> w<span class="token punctuation">,</span> v<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
    	cin <span class="token operator">>></span> w <span class="token operator">>></span> v <span class="token operator">>></span> c<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>w<span class="token operator">*</span>c <span class="token operator">></span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//如果  数量*重量 >= 总重量，考虑完全背包</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> w<span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span><span class="token punctuation">&#123;</span> <span class="token comment">//否则  考虑01背包二进制写法</span>
            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token operator">&lt;</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            	<span class="token comment">//拆分时我们就可以按照01背包求解</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span>j <span class="token operator">>=</span> w<span class="token operator">*</span>k<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token operator">*</span>k<span class="token punctuation">]</span><span class="token operator">+</span>k<span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
                c <span class="token operator">-=</span> k<span class="token punctuation">,</span> k <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span>j <span class="token operator">>=</span> w<span class="token operator">*</span>c<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token operator">*</span>c<span class="token punctuation">]</span><span class="token operator">+</span>c<span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="分组背包">分组背包</h2>
<p>分组背包指的是物品被划分为<span
class="math inline">\(k\)</span>组，而每组中的物品互相冲突，最多选一件。</p>
<p>01背包和其相比，相当于每组只有一个物品。因此同样的我们还是用<span
class="math inline">\(f[k, j]\)</span>表示前<span
class="math inline">\(k\)</span>组物品装到容量为<span
class="math inline">\(j\)</span>的背包的最大总重量，只是限定每组选一件，但是不知道会选哪一件，需要枚举这组中每一件物品计算能够得到的最大价值数。这里以<a
href="https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P1757/origin">洛谷-P1757
通天之分组背包</a>为例来说明：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 4-1-1</span>
<span class="token comment">/*
分组背包+ 滚动数组优化 
*/</span> 
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> w<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span>
<span class="token keyword">int</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
		a<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">++</span>a<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> t<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				<span class="token keyword">int</span> id <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>w<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//				cout &lt;&lt; f[k][j] &lt;&lt; " ";</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">//滚动数组优化 </span>
<span class="token comment">//		for(int j = m; j >=0; j--)&#123;</span>
<span class="token comment">//			for(int i = 1; i &lt;= a[k][0]; i++)&#123;</span>
<span class="token comment">//				int id = a[k][i];</span>
<span class="token comment">//				if(j>=w[id]) dp[j] = max(dp[j], dp[j-w[id]]+v[id]);</span>
<span class="token comment">//			&#125;</span>
<span class="token comment">//		&#125; </span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//	printf("%d", dp[m]);</span>
<span class="token punctuation">&#125;</span> </code></pre>
<h2 id="二维费用背包">二维费用背包</h2>
<p>二维费用的背包问题指的是：对于每件物品，具有两种不同的费用，并且选择这件物品必须同时付出这两种代价。</p>
<p>费用增加了一维，只需状态增加一维即可。我们用<span
class="math inline">\(f[i][j][k]\)</span>表示前<span
class="math inline">\(i\)</span>件物品 付出两种费用分别为<span
class="math inline">\(j\)</span>和<span
class="math inline">\(k\)</span>时可获得的最大价值，递推式如下：<br />
<span class="math display">\[f[i][j][k] = max(f[i-1][j][k],
f[i-1][j-w1[i]][k-w2[i]]+v[i])\]</span></p>
<p>同样的我们可以使用滚动数组优化空间，这里以<a
href="https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P1855/origin">洛谷-P1855
榨取kkksc03</a>为例题说明：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//code 5-1-1</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> n<span class="token punctuation">,</span> M<span class="token punctuation">,</span> T<span class="token punctuation">,</span> m<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">210</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">210</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>M<span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//朴素解法 68ms</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> M<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> T<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        		f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
        		<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>k<span class="token operator">>=</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        			f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">-</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span> 
		<span class="token comment">// 滚动数组优化 43ms </span>
<span class="token comment">//        for(int j = M; j >= m[i]; j--)</span>
<span class="token comment">//	        for(int k = T; k >= t[i]; k--)&#123;</span>
<span class="token comment">//	            dp[j][k] = max(dp[j][k], dp[j-m[i]][k-t[i]]+1);</span>
<span class="token comment">//	        &#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token comment">//    printf("%d", dp[M][T]);</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>图论—最小生成树</title>
    <url>/posts/44458.html</url>
    <content><![CDATA[<p>和最短路径相似，甚至比它更加不注重证明过程，知道最小生成树的概念以及如何去求就已经足够了，将不再详细注明证明过程。实话实说这个证明看一次理解一次，过段时间又会忘掉，并且重点就是每次重新理解最小生成树算法的正确性还得花费一定的时间，并不是说我能够用一种很形象的理解一下子就能够回想起来。</p>
<h2 id="概念">概念</h2>
<p><strong>生成子图：</strong><br />
对一张图 <span class="math inline">\(G = (V, E)\)</span>，若存在另一张图
<span class="math inline">\(H = (V&#39;, E&#39;)\)</span> 满足 <span
class="math inline">\(V&#39; \subseteq V\)</span> 且 <span
class="math inline">\(E&#39; \subseteq E\)</span>，则称 <span
class="math inline">\(H\)</span> 是 <span
class="math inline">\(G\)</span> 的 <strong>子图
(subgraph)</strong>，记作 <span class="math inline">\(H \subseteq
G\)</span>。</p>
<p>若 <span class="math inline">\(H \subseteq G\)</span> 满足 <span
class="math inline">\(V&#39; = V\)</span>，则称 <span
class="math inline">\(H\)</span> 为 <span
class="math inline">\(G\)</span> 的 <strong>生成子图(spanning
subgraph)</strong></p>
<p><strong>生成树：</strong><br />
一个连通无向图的生成子图，同时要求是树。也即在图的边集中选择<span
class="math inline">\(n-1\)</span>条，将所有顶点连通。(<span
class="math inline">\(n\)</span>个节点的树有<span
class="math inline">\(n-1\)</span>条边)</p>
<p>我们定义无向连通图的 <strong>最小生成树</strong>（Minimum Spanning
Tree，MST）为边权和最小的生成树。</p>
<p><code>注意</code><br />
只有连通图才有生成树，而对于非连通图，只存在生成森林。</p>
<h2 id="prim算法">Prim算法</h2>
<p>首先，我们假设有一颗只包含一个顶点<span
class="math inline">\(v\)</span>的树<span
class="math inline">\(T\)</span>。然后贪心地选取<span
class="math inline">\(T\)</span>和其他顶点之间相连地最小权值的边，并把它加到<span
class="math inline">\(T\)</span>中。不断进行这个操作，就可以得到一颗生成树了。如下图所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/图论/prim算法.png" /></p>
<p>下面以<a href="">洛谷-P3366 【模板】最小生成树</a>为例说明：</p>
<ol type="1">
<li><p>一种是原始的prim算法 <pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">inf</span> <span class="token expression"><span class="token number">0x3f3f3f3f</span></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">4e5</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
<span class="token keyword">int</span> head<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>
<span class="token keyword">int</span> tot<span class="token punctuation">,</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> ans<span class="token punctuation">;</span>
<span class="token keyword">bool</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> to<span class="token punctuation">,</span> val<span class="token punctuation">,</span> nxt<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	e<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>to <span class="token operator">=</span> v<span class="token punctuation">;</span>
	e<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>val <span class="token operator">=</span> w<span class="token punctuation">;</span>
	e<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>nxt <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
	head<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//原版 </span>
<span class="token keyword">void</span> <span class="token function">prim1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>
	dis<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> dis<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">//寻找距离生成树最小的顶点 </span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>
				u <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>u<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//所有顶点均已加入生成树 </span>
		tot<span class="token operator">++</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> ans <span class="token operator">+=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token comment">//更新dis数组，即生成树和其他顶点间的距离 </span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nxt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">,</span> w <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">></span>w<span class="token punctuation">)</span> dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span>
		cin <span class="token operator">>></span> u <span class="token operator">>></span> v <span class="token operator">>></span> w<span class="token punctuation">;</span>
		<span class="token function">add</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">prim1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>tot<span class="token operator">==</span>n<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"orz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre></p></li>
<li><p>另一种是用堆优化每次取出生成树距离最近的点，其中对于<code>if(vis[u]) continue</code>的解释为：节点已经加入生成树则忽略，如下图所示<br />
<img data-src="../images/NOI暑假培训/算法专题/图论/最小生成树%20prim算法%20vis%5B%5D的使用.png" />
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> pos<span class="token punctuation">,</span> dis<span class="token punctuation">;</span>
	<span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>node a<span class="token punctuation">,</span> node b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> a<span class="token punctuation">.</span>dis <span class="token operator">></span> b<span class="token punctuation">.</span>dis<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">//堆优化 </span>
<span class="token keyword">void</span> <span class="token function">prim2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	priority_queue<span class="token operator">&lt;</span>node<span class="token operator">></span> que<span class="token punctuation">;</span> <span class="token comment">//用于寻找与生成树距离最近的点 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>
	dis<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		node now <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> u <span class="token operator">=</span> now<span class="token punctuation">.</span>pos<span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">//若节点已经加入生成树则忽略 </span>
		tot<span class="token operator">++</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> ans <span class="token operator">+=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nxt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">,</span> w <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">></span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>
				que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>v<span class="token punctuation">,</span> w<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></p></li>
</ol>
<h2 id="kruskal-算法">Kruskal 算法</h2>
<p>Kruskal
算法按照边的权值的顺序从小到大查看一遍，如果不产生圈，就把当前这条边加入到生成树中。</p>
<p>接下来我们介绍如何判断产生圈。假设现在要把连接顶点<span
class="math inline">\(u\)</span>和顶点<span
class="math inline">\(v\)</span>的边<span
class="math inline">\(e\)</span>加入生成树中，如果加入之前<span
class="math inline">\(u\)</span>和<span
class="math inline">\(v\)</span>不在同一个联通分量里，那么加入<span
class="math inline">\(e\)</span>也不会产生圈；反之，如果<span
class="math inline">\(u\)</span>和<span
class="math inline">\(v\)</span>在同一个联通分量里，那么一定会产生圈。可以使用并查集高效地判断是否属于同一个联通分量。</p>
<h3 id="并查集">并查集</h3>
<p>并查集就是维护了几个动态的集合。集合中的每一个元素都标记了一个父节点，同一个集合的代表是相同的。<strong>当一个元素的父节点就是他本身时，它就是该集合的代表。</strong></p>
<p><strong>初始时</strong><br />
<img data-src="../images/NOI暑假培训/算法专题/图论/并查集初始化.png" /><br />
<strong>合并</strong><br />
从一个组的根向另一个组的根连边，这样两颗树就变成了一棵树，也就把两个组合并为一个组了<br />
<img data-src="../images/NOI暑假培训/算法专题/图论/并查集合并1.png" /></p>
<p><strong>查询</strong><br />
沿着树向上走就能查询到包含着这个元素的树的根是谁。若两个节点走到同一个根，代表属于同一个集合。<br />
<img data-src="../images/NOI暑假培训/算法专题/图论/并查集合并1.png" /><br />
<img data-src="../images/NOI暑假培训/算法专题/图论/并查集合并2.png" /><br />
<strong><code>路径压缩</code></strong><br />
通过路径压缩，可以使得并查集更加高效，一旦向上到了一次根节点，就把这个点到父亲的边改为直接连向根<br />
<img data-src="../images/NOI暑假培训/算法专题/图论/并查集路径压缩1.png" /></p>
<p>在此之上，不仅仅是所查询的节点，在查询过程中向上经过的所有节点，都改为直接连到根上。这样再次查询这些节点时，就可以很快知道根是谁了。<br />
<img data-src="../images/NOI暑假培训/算法专题/图论/并查集路径压缩2.png" /></p>
<p>下面以为<a href="https://vjudge.net/problem/HDU-1232">HDU-1232
畅通工程</a>例说明其具体实现，细节见注释：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
<span class="token keyword">int</span> fa<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//并查集寻找根节点（含路径压缩） </span>
<span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">!=</span>fa<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> fa<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//合并 </span>
<span class="token keyword">void</span> <span class="token function">unite</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">!=</span>v<span class="token punctuation">)</span> fa<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> fa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>
			<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>u<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">unite</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">//确定连通分量个数  </span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>i<span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> cnt<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>至此，对并查集有了基本的理解。接着我们可以用并查集维护Kruskal
算法中的联通分量：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">5e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">,</span> maxm <span class="token operator">=</span> <span class="token number">2e5</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
<span class="token keyword">int</span> fa<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> ans<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>e<span class="token punctuation">[</span>maxm<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>edge a<span class="token punctuation">,</span> edge b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> a<span class="token punctuation">.</span>w <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>w<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">!=</span>fa<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> fa<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> 
<span class="token keyword">void</span> <span class="token function">kruskal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">sort</span><span class="token punctuation">(</span>e<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> e<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>m<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将边排序 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">==</span>v<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token comment">//将边加入生成树并统计答案 </span>
		fa<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
		cnt<span class="token operator">++</span><span class="token punctuation">,</span> ans <span class="token operator">+=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> fa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		cin <span class="token operator">>></span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u <span class="token operator">>></span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">>></span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
	<span class="token function">kruskal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">==</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"orz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<h2 id="总结">总结</h2>
<p>在稠密图中，原版的Prim算法复杂度较优，但在稀疏图中，堆优化的Prim以及Kruskal算法表现会更好。在应用时，我们可以根据实际情况选择最优的算法。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>图论—最短路径</title>
    <url>/posts/27030.html</url>
    <content><![CDATA[<p>本来的思路是想像当年我学最短路一样，讲解算法的证明，但是后来仔细一想发现这样他们既不能很好的理解，又不能很好的在比赛中发挥出来。由于人的精力有限并且有的知识点本身就不常用，在此选择教授最常用的内容并用通俗易懂的方式讲给他们听。</p>
<h2 id="前言">前言</h2>
<p>在最基本的广度优先搜索中,每次沿着分支的扩展都记为“一步”，我们通过逐层搜索,解决了求从起始状态到每个状态的最少步数的问题。这其实等价于在一张边权均为1的图上执行广度优先遍历，求出每个点相对于起点的最短距离(层次)</p>
<p>然而，如果图上的边权不全是1呢?换句话说，如果每次扩展都有各自不同的“代价”，我们想求出起始状态到每个状态的最小代价,应该怎么办呢?</p>
<p>对于更加具有普适性的情况，也就是每次扩展都有各自不同的“代价”时，求出起始状态到每个状态的最小代价，就相当于在一张带权图上求出从起点到每个节点的最短路。此时，我们有两个解决方案:<br />
<strong>方法一</strong><br />
仍然使用一般的广搜，采用一般的队列。</p>
<p>这时我们不再能保证每个状态第一次入队时就能得到最小代价，所以只能允许一个状态被多次更新、多次进出队列。我们不断执行搜索，直到队列为空。</p>
<p>整个广搜算法对搜索树进行了重复遍历与更新，直至“收敛”到最优解，其实也就是“迭代”的思想。</p>
<p>对应在最短路问题中，就是我们将会介绍的SPFA 算法。</p>
<p><strong>方法二</strong><br />
改用优先队列进行广搜。</p>
<p>这里的“优先队列”就相当于一个二叉堆。我们可以每次从队列中取出当前代价最小的状态进行扩展(该状态一定已经是最优的,因为队列中其他状态的当前代价都不小于它,所以以后就不可能再更新它了),沿着各条分支把到达的新状态加入优先队列。不断执行搜索，直到队列为空。</p>
<p>对应在最短路问题中，就是我们将会介绍的堆优化的 Dijkstra算法。</p>
<h2 id="图的存储">图的存储</h2>
<p>想要对图进行操作，就需要先学习图的存储方式。</p>
<h3 id="邻接矩阵">邻接矩阵</h3>
<p>使用一个二维数组 <code>edge</code> 来存边，其中
<code>edge[u][v]</code> 为 1 表示存在 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 的边，为 0
表示不存在。如果是带边权的图，可以在 <code>edge[u][v]</code> 中存储
<span class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 的边的边权。</p>
<p>邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵。</p>
<h3 id="邻接表">邻接表</h3>
<p>使用一个支持动态增加元素的数据结构构成的数组，如 <code>vector&lt;pair&lt;int,int&gt; &gt; edge[n]</code> 来存边，其中 <code>edge[u]</code> 存储的是点<span
class="math inline">\(u\)</span>的所有出边的相关信息（终点、边权等）。</p>
<p>存各种图都很适合，尤其适用于需要对一个点的所有出边进行排序的场合。</p>
<h4 id="链式前向星">链式前向星</h4>
<p>本质上是用链表实现的邻接表，具体实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  nxt<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前边的后继</span>
  head<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>         <span class="token comment">// 起点 u 的第一条边</span>
  to<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>           <span class="token comment">// 当前边的终点</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 遍历 u 的出边</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">=</span> nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
  <span class="token keyword">int</span> v <span class="token operator">=</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>将<span class="math inline">\(to\)</span>数组和<span
class="math inline">\(nxt\)</span>数组信息写在结构体里也是可以的：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> to<span class="token punctuation">,</span> nxt<span class="token punctuation">,</span> cost<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>e<span class="token punctuation">[</span>maxm<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<h2 id="单源最短路径">单源最短路径</h2>
<h3 id="松弛操作">松弛操作</h3>
<p>先介绍最短路径要用到的松弛操作，这是这类算法的理论基础：</p>
<p>对于一条从<span class="math inline">\(u\)</span>到<span
class="math inline">\(v\)</span>，长度为<span
class="math inline">\(w\)</span>的连边，如果<span
class="math inline">\(dis_u + w &lt; dis_v\)</span>，那么就可以将<span
class="math inline">\(dis_v\)</span>的变成<span
class="math inline">\(dis_u+w\)</span>，因为这代表这从<span
class="math inline">\(s\)</span>走到<span
class="math inline">\(u\)</span>经过这条边再走到<span
class="math inline">\(v\)</span>是一条未被发现过的，且比原先的最优路径还要短的边</p>
<h3 id="dijkstra算法">Dijkstra算法</h3>
<p>Dijkstra算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。
它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p>
<h4 id="重要思想">重要思想</h4>
<p>以前学习的时候参考了《算法》、《挑战程序设计》还有网上博客等等，大多时候都是用数学归纳法或者其他的严谨证明，然而事实是每隔一段时间不接触就会忘记其正确性是如何被证明的。最后要么就是不理解，要么就是又重新证明一遍，依次反复，这不是个办法。因此还是要形象、通俗易懂的理解较好，下面引用当时考PTA甲级时候的思考：</p>
<blockquote>
<p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。最短路径问题也是
<span class="math inline">\(BFS\)</span>
的典型应用，而且其方法与层序遍历关系密切。</p>
<p>在二叉树中，<span class="math inline">\(BFS\)</span>
可以实现一层一层的遍历。在图中同样如此。从源点出发，<span
class="math inline">\(BFS\)</span> 首先遍历到第一层结点，到源点的距离为
1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 <span
class="math inline">\(BFS\)</span>
的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p>
<p><img data-src="../images/NOI暑假培训/算法专题/图论/最短路1-1.png" /></p>
<p>我们在原图的节点间中添加若干个节点使得它们的间距都为1，这时可以把<span
class="math inline">\(Dijkstra\)</span>看作成<span
class="math inline">\(BFS\)</span>。像蜻蜓点水一样，由近及远，层层往远处遍历，遍历到的点即是最短距离。但是很明显中间的若干节点不需要遍历到，模拟这个过程只需要保证水波边缘处于最近的层数即可。</p>
<p><img data-src="../images/NOI暑假培训/算法专题/图论/最短路1-2.png" /></p>
<p><img data-src="../images/NOI暑假培训/算法专题/图论/最短路1-3.png" /></p>
</blockquote>
<p>到这里我们可以想到从当前<span
class="math inline">\(dis\)</span>最小的点<span
class="math inline">\(u\)</span>出发松弛边就是为了寻找"处于水波边缘最近的层数"，因为他们可能离源点更近，而不一定是上一次搜索到的点。最后取出操作后最小的<span
class="math inline">\(dis\)</span>就是此时"最近的层数"。</p>
<h4 id="具体实现">具体实现</h4>
<ol type="1">
<li>将起始点<span class="math inline">\(s\)</span>的<span
class="math inline">\(dis\)</span>置为0，其他置为<span
class="math inline">\(+\infty\)</span> </li>
<li>选择当前未标记的点中<span
class="math inline">\(dis\)</span>值最小的一个</li>
<li>对该点的所有连边依次进行松弛操作</li>
<li>对该点进行标记</li>
<li>重复第二步至第四步，直到不存在一条从已标记点通往未标记点的连边</li>
</ol>
<p>示例见下图：<br />
<img data-src="../images/NOI暑假培训/算法专题/图论/dijkstra.png" /></p>
<p><strong>与每次花费<span
class="math inline">\(O(n)\)</span>的时间寻找<span
class="math inline">\(dis\)</span>最小的点相比，我们可以使用一个小根堆来维护<span
class="math inline">\(dis\)</span>最小的点</strong>。每次松弛成功时，将被松弛的边的终点和对应的<span
class="math inline">\(dis\)</span>打包放入堆中，需要<span
class="math inline">\(dis\)</span>最小的点时将堆顶端的点取出即可。代码实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> to<span class="token punctuation">,</span> cost<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>node<span class="token operator">></span> g<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    priority_queue<span class="token operator">&lt;</span>pii<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pii<span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pii<span class="token operator">></span> <span class="token operator">></span>que<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>
    d<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        pii p <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> u <span class="token operator">=</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">//也可以使用d[u]&lt;p.first</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> v <span class="token operator">=</span> g<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">,</span> cost <span class="token operator">=</span> g<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cost<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">></span>d<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>cost<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                d<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">;</span>
                que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>d<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> cost<span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>u<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cost<span class="token punctuation">)</span><span class="token punctuation">;</span>
        g<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">pb</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>v<span class="token punctuation">,</span> cost<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">pb</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>u<span class="token punctuation">,</span> cost<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
	<span class="token function">dijkstra</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><code>语法参考</code><br />
<strong>priority_queue</strong>是种一种功能强大的队列，本质是一个堆<br />
比较方式默认用operator&lt;，所以如果把后面2个参数缺省的话，优先队列就是大顶堆（降序），队头元素最大。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//下面两种优先队列的定义是等价的</span>
priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span><span class="token comment">//默认的优先队列</span>
priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span>less<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> q<span class="token punctuation">;</span>
<span class="token comment">//注意最后两个“>”符号不要连在一起，否则会被很多（但不是所有）编译器误认为是‘>>’运算符</span></code></pre>
<p>如果想让优先队列总是把最小的元素放在队首，只需进行如下的定义：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"> priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span>greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span>q<span class="token punctuation">;</span> </code></pre>
<p>less 表示数字大的优先级高，而 greater表示数字小的优先级高</p>
<h4 id="注意事项">注意事项</h4>
<p><strong>Dijkstra算法不适用于边长出现负数的情况</strong>。要证明一个问题是正确的我们需要从多方面严谨推理，但是要说明一个问题是错误的，我们只需举个反例即可。</p>
<p>如下图，我们设置<span
class="math inline">\(A\)</span>为源点时，首先会将点<span
class="math inline">\(B\)</span>和点<span
class="math inline">\(C\)</span>的<span
class="math inline">\(dis\)</span>值变为-1和1，接着由于点<span
class="math inline">\(B\)</span>的<span
class="math inline">\(dis\)</span>值最小，因此用点<span
class="math inline">\(B\)</span>去更新其未访问的邻接点（虽然并没有)。在这之后点<span
class="math inline">\(B\)</span>标记为已访问，于是将无法被从点<span
class="math inline">\(C\)</span>出发的边<span
class="math inline">\(CB\)</span>更新，因此最后<span
class="math inline">\(dist[B]\)</span>就是-1，但显然<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的最短路为<span
class="math inline">\(A\rightarrow C\rightarrow B\)</span>的-4<br />
<img data-src="../images/NOI暑假培训/算法专题/图论/dijkstra%20负权图示例图.png" /></p>
<h3 id="bellman-ford算法和spfa算法">Bellman-Ford算法和SPFA算法</h3>
<p>Bellman-Ford
算法是一种基于松弛（relax）操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断。</p>
<p>Bellman-Ford
算法所做的，就是不断尝试对图上每一条边进行松弛。<strong>我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。</strong></p>
<h4 id="负环判断">负环判断</h4>
<p><strong>在最短路存在的情况下，由于一次松弛操作会使最短路的边数至少
<span class="math inline">\(+1\)</span></strong>，而最短路的边数最多为
<span class="math inline">\(n-1\)</span>（因为最多经过<span
class="math inline">\(n\)</span>个点），因此整个算法最多执行 <span
class="math inline">\(n-1\)</span> 轮松弛操作。</p>
<p>但还有一种情况，如果从 <span class="math inline">\(S\)</span>
点出发，抵达一个负环时，松弛操作会无休止地进行下去。注意到前面的论证中已经说明了，对于最短路存在的图，松弛操作最多只会执行
<span class="math inline">\(n-1\)</span> 轮，因此如果第 <span
class="math inline">\(n\)</span> 轮循环时仍然存在能松弛的边，说明从
<span class="math inline">\(S\)</span> 点出发，能够抵达一个负环。</p>
<p>具体实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edge</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">bellmanford</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>
  dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">bool</span> flag<span class="token punctuation">;</span>  <span class="token comment">// 判断一轮循环过程中是否发生松弛操作</span>
  <span class="token comment">//一条最短路最多经过n个点，因此最多松弛n-1次</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token comment">//遍历所有的边</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> u <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> u<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	  <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> inf<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
	  <span class="token comment">// 无穷大与常数加减仍然为无穷大</span>
	  <span class="token comment">// 因此最短路长度为 inf 的点引出的边不可能发生松弛操作</span>
	  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> w <span class="token operator">=</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		  dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span>
		  flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	  <span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 没有可以松弛的边时就停止算法</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 第 n 轮循环仍然可以松弛时说明 s 点可以抵达一个负环</span>
  <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong><code>负环判断中存在的常见误区</code></strong><br />
需要注意的是，以 <span class="math inline">\(S\)</span> 点为源点跑
Bellman-Ford 算法时，如果没有给出存在负环的结果，只能说明从 <span
class="math inline">\(S\)</span>
点出发不能抵达一个负环，而不能说明图上不存在负环。</p>
<p>因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为
0 的边，然后以超级源点为起点执行 Bellman-Ford 算法。</p>
<h4 id="队列优化spfa">队列优化SPFA</h4>
<p>很多时候我们并不需要那么多无用的松弛操作。</p>
<p>很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。（正面看是因为这样可能使其他点到源点的路径更短，反面看否则上一次其他节点连接的边已经引起松弛操作了）</p>
<p>那么我们用队列来维护“哪些结点可能会引起松弛操作”，就能只访问必要的边了。具体实现如下：</p>
<p><strong>其中<span
class="math inline">\(vis[]\)</span>用于记录每个点是否处在队列中</strong>，其作用例子如下图所示，搜索过的点（如图中先染上橙色后为黄色的点）可能还需要继续更新，这就是为什么<span
class="math inline">\(vis[]\)</span>标记一个点入队并使用完后，要取消标记的原因<br />
<img data-src="../images/NOI暑假培训/算法专题/图论/spfa%20vis%5B%5D数组示例.png" /></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edge</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> e<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>

queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>
  dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//vis[]用于记录每个点是否处在队列中</span>
    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> w <span class="token operator">=</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span>
        cnt<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 记录最短路经过的边数</span>
        <span class="token comment">// 在不经过负环的情况下，最短路至多经过 n - 1 条边</span>
        <span class="token comment">// 因此如果经过了多于 n 条边，一定说明经过了负环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">>=</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token comment">//松弛成功且不在队列中则入队</span>
		<span class="token comment">//之后需要通过这个点连接的边进行松弛操作, 而这个点可能之前就在队列里</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><code>注意</code><br />
在没有负权边时最好使用 Dijkstra
算法，因为出题人构造特定数据可能使其超时</p>
<h2 id="多源最短路径">多源最短路径</h2>
<p>同样是最短路径问题，而和单源最短路径不同的是它需要处理从不同点出发的最短路径</p>
<h3 id="floyd算法">Floyd算法</h3>
<p>采用动态规划的思路。设<span class="math inline">\(dis[i, j,
k]\)</span>表示途径编号<span class="math inline">\(1\sim
k\)</span>的点时，<span class="math inline">\(i\)</span>到<span
class="math inline">\(j\)</span>的最短路的长度。答案就是<span
class="math inline">\(dis[i, j, n]\)</span></p>
<p>考虑递推关系，可以选择经过 / 不经过第<span
class="math inline">\(k\)</span>个点：<br />
<span class="math display">\[dis[i, j, k] = min(dis[i, j, k-1], dis[i,
k, k-1]+dis[k, j, k-1])\]</span></p>
<p>特别需要注意<code>dis[x][y][0]</code>：<span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 的边权，或者 <span
class="math inline">\(0\)</span>，或者 <span
class="math inline">\(+\infty\)</span>（<code>dis[x][y][0]</code>
什么时候应该是 <span class="math inline">\(+\infty\)</span>？当 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span>
间有直接相连的边的时候，为它们的边权；当 <span class="math inline">\(x =
y\)</span> 的时候为零，因为到本身的距离为零；当 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 没有直接相连的边的时候，为 <span
class="math inline">\(+\infty\)</span>）。</p>
<p>由于在递推过程中，第三维为<span
class="math inline">\(k\)</span>时需要用到第三维为<span
class="math inline">\(k-1\)</span>的数据，所以在枚举时应当先枚举第三维<span
class="math inline">\(k\)</span>，如下所示：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>dis<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre>
<p>回忆下01背包滚动数据优化空间的办法，就能发现这里同样能够进行优化，只需要把递推式写成：<br />
<span class="math display">\[dis[i, j] = min(dis[i, j], dis[i, k]+dis[k,
j])\]</span></p>
<p>可以证明，当存在负权边时Floyd算法正确性可以保证。</p>
<h3 id="应用">应用</h3>
<h4 id="求传递闭包">求传递闭包</h4>
<p>已知一个有向图中任意两点之间是否有连边，要求判断任意两点是否连通。</p>
<p>只需要将<span class="math inline">\(f[i, j,
k]\)</span>表示途径编号<span class="math inline">\(1\sim
k\)</span>的点时，<span
class="math inline">\(i\)</span>能否直接或间接到达<span
class="math inline">\(j\)</span>即可，写出递推关系式：<br />
<span class="math display">\[f[i, j, k] = f[i, j, k] \vee f[i, k,
k-1]\wedge f[k, j, k-1]\]</span></p>
<p>同理，可以用滚动数组优化空间。</p>
<p><code>提示</code><br />
许多算法竞赛题目看起来和图没什么关系，但是如果可以找到状态节点和连接不同节点的边，也可以将其建立图模型，使用图论算法解决</p>
<h2 id="输出方案">输出方案</h2>
<p>开一个 <code>pre</code> 数组，在更新距离的时候记录下来后面的点是如何转移过去的，算法结束前再递归地输出路径即可。</p>
<p>比如 Dijkstra 一般记录 <code>pre[v] = u</code>，Floyd
就要记录 <code>pre[i][j] = k;</code></p>
<h2 id="练习巩固">练习巩固</h2>
<p><strong>1. 洛谷-P3371 【模板】单源最短路径（弱化版）</strong></p>
<p>使用dijkstra（堆优化）求源点到图中其他点的最短路的值</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">pii</span> <span class="token expression">pair<span class="token operator">&lt;</span>ll<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span>
<span class="token comment">//注意使用2e32-1是错误的 </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">inf</span> <span class="token expression"><span class="token number">2147483647</span></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e4</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">,</span> maxm <span class="token operator">=</span> <span class="token number">5e5</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> s<span class="token punctuation">;</span>
<span class="token keyword">int</span> head<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>
<span class="token keyword">bool</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
ll dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> to<span class="token punctuation">,</span> nxt<span class="token punctuation">,</span> cost<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>e<span class="token punctuation">[</span>maxm<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">,</span><span class="token keyword">int</span> w<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	e<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>to <span class="token operator">=</span> v<span class="token punctuation">;</span>
	e<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>cost <span class="token operator">=</span> w<span class="token punctuation">;</span>
	e<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>nxt <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
	head<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//朴素做法 </span>
<span class="token keyword">void</span> <span class="token function">dijkstra1</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>
	dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//循环直到所有点找到最短路径</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nxt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>dis<span class="token punctuation">[</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token operator">></span>dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cost<span class="token punctuation">)</span>
				dis<span class="token punctuation">[</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cost<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">//在未标记的点中找出dis最小的点 </span>
		ll minDis <span class="token operator">=</span> inf<span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>minDis<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				minDis <span class="token operator">=</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				u <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//堆优化 </span>
<span class="token keyword">void</span> <span class="token function">dijkstra2</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	priority_queue<span class="token operator">&lt;</span>pii<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pii<span class="token operator">></span><span class="token punctuation">,</span>greater<span class="token operator">&lt;</span>pii<span class="token operator">></span> <span class="token operator">></span>que<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>
	dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		pii now <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> u <span class="token operator">=</span> now<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nxt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">></span>dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cost<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				<span class="token comment">//松弛操作</span>
				dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cost<span class="token punctuation">;</span>
				<span class="token comment">//把新遍历到的点加入堆中</span>
            	que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	cin <span class="token operator">>></span> n <span class="token operator">>></span> m <span class="token operator">>></span> s<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span>
		cin <span class="token operator">>></span> u <span class="token operator">>></span> v <span class="token operator">>></span> w<span class="token punctuation">;</span>
		<span class="token function">add</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">dijkstra2</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</code></pre>
<p><strong>2. 洛谷-P3385 负环</strong></p>
<p>使用SPFA判断是否存在源点能够到达的负环</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">inf</span> <span class="token expression"><span class="token number">0x3f3f3f</span> </span></span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">2e3</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span> maxm <span class="token operator">=</span> <span class="token number">6e3</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
<span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> head<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> tot<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> to<span class="token punctuation">,</span> nxt<span class="token punctuation">,</span> w<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>e<span class="token punctuation">[</span>maxm<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment">//有多组测试数据，每次需要初始化</span>
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> head<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//初始化节点指向的第一条边 </span>
	tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//使得边重新计数 </span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	e<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token operator">=</span>v<span class="token punctuation">;</span>
	e<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span>
	e<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>nxt <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
	head<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> tot<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">bool</span> <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">,</span> vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	dis<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> u <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// vis[]用于记录每个点是否处在队列中 </span>
		vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nxt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">,</span> w <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">></span>dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span>  <span class="token comment">//更新最短路</span>
				cnt<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 记录最短路经过的边数</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">>=</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">//判定存在负环</span>
				<span class="token comment">//松弛成功且不在队列中则入队</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> t<span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	whilet<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span>
			<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>u<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">add</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>w<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token string">"YES"</span><span class="token operator">:</span><span class="token string">"NO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong>3. HDU-1385 Minimum Transport Cost</strong></p>
<p>floyd求多源最短路+输出方案。<br />
<span
class="math inline">\(pre[i][j]\)</span>表示i到j的路径上的首个中转城市,
这是最关键的地方</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*

ref: https://vjudge.net/solution/32201255
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">inf</span> <span class="token expression"><span class="token number">0x3f3f3f3f</span></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> tax<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> f<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> pre<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">floyd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>tax<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
					f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>tax<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
					pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>tax<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
					pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>
				pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">floyd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>u<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>u<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>v<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"From %d to %d:\n"</span><span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Path: %d"</span><span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> st <span class="token operator">=</span> u<span class="token punctuation">,</span> ed <span class="token operator">=</span> v<span class="token punctuation">;</span>
			<span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token operator">!=</span>ed<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-->%d"</span><span class="token punctuation">,</span> pre<span class="token punctuation">[</span>st<span class="token punctuation">]</span><span class="token punctuation">[</span>ed<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				st <span class="token operator">=</span> pre<span class="token punctuation">[</span>st<span class="token punctuation">]</span><span class="token punctuation">[</span>ed<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nTotal cost:%d\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong>4. 洛谷-B3611 【模板】传递闭包</strong></p>
<p>floyd判断两点是否连通</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            cin <span class="token operator">>></span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|=</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<hr />
<p>参考自：<br />
<a href="https://oi-wiki.org/graph/save/">OI-Wiki 图的存储</a></p>
<p><em>Algorithms - Sanjoy Dasgupta, Christos H. Papadimitriou, and
Umesh V. Vazirani</em><br />
<a
href="https://segmentfault.com/a/1190000008235554">Dijkstra最短路径算法的理解与实现</a><br />
<a
href="https://www.cnblogs.com/sbb-first-blog/p/13259728.html">BFS(广度优先搜索)：层序遍历和最短路径</a><br />
<a
href="https://www.zhihu.com/question/68753603/answer/267513879">阮行止对最短路的理解</a></p>
<p><a
href="https://wat1r.github.io/2020/09/23/dijkstra-algorithm-master/">一文掌握Dijkstra算法</a><br />
<a href="https://oi-wiki.org/graph/shortest-path/">OI-Wiki
最短路</a><br />
<a
href="https://blog.51cto.com/u_14301180/5353950">dijkstra算法为什么不能有负边？</a></p>
<p>《深入浅出程序设计竞赛—基础篇》<br />
《算法竞赛进阶指南》<br />
《挑战程序设计竞赛》</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/posts/61237.html</url>
    <content><![CDATA[<h2 id="选择排序插入排序冒泡排序">选择排序、插入排序、冒泡排序</h2>
<p>这三类算法都比较简单，相对应的时间复杂度也较高，为<span
class="math inline">\(O(n^2)\)</span></p>
<h3 id="选择排序">选择排序</h3>
<p>选择排序（Selection
sort）是一种简单直观的排序算法。它的工作原理是每次找出第<span
class="math inline">\(i\)</span>小的元素（也就是<span
class="math inline">\(A_i, A_{i+1},...,
A_n\)</span>中最小的元素），然后将这个元素与数组第<span
class="math inline">\(i\)</span>个位置上的元素交换。</p>
<p>下面以<a
href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-350">计蒜客-350
选择排序</a>为例说明其具体实现：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> n<span class="token punctuation">,</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> id <span class="token operator">=</span> i<span class="token punctuation">,</span> tmp<span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span> id <span class="token operator">=</span> j<span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">==</span>i<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
		tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<h3 id="冒泡排序">冒泡排序</h3>
<p>冒泡排序（Bubble
sort）是一种简单的排序算法。由于在算法的执行过程中，较小的元素像是气泡般慢慢「浮」到数列的顶端，故叫做冒泡排序。</p>
<p>它的工作原理是每次检查相邻两个元素，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。因此冒泡排序最多需要扫描<span
class="math inline">\(n-1\)</span>遍数组就能完成排序。</p>
<p>有一种考法就是要求求出冒泡排序中元素的交换次序，如<a
href="https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P1116">洛谷-P1116
车厢重组</a>：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e4</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>
<span class="token keyword">int</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token comment">//	for(int i = 1; i &lt;= n; i++)</span>
<span class="token comment">//		printf("%d ", a[i]);</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<h3 id="插入排序">插入排序</h3>
<p>插入排序（Insertion
sort）是一种简单直观的排序算法。它的工作原理为将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。</p>
<p>以<a
href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-A1044">计蒜客-A1044
排序</a>为例说明其具体实现，实现细节见注释：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e4</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	        <span class="token keyword">int</span> key <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//待排序第一个元素</span>
	        <span class="token keyword">int</span> i <span class="token operator">=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//代表已经排过序的元素最后一个索引数</span>
	        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	            <span class="token comment">//从后向前逐个比较已经排序过数组，如果比它小，则把后者用前者代替，</span>
	            <span class="token comment">//其实说白了就是数组逐个后移动一位,为找到合适的位置时候便于Key的插入</span>
	            a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	            i<span class="token operator">--</span><span class="token punctuation">;</span>
	        <span class="token punctuation">&#125;</span>
	        a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token comment">//找到合适的位置了，赋值,在i索引的后面设置key值。</span>
	    <span class="token punctuation">&#125;</span>
	    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>mode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	    		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    		i<span class="token operator">!=</span>n <span class="token operator">?</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    		i<span class="token operator">!=</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	    
	<span class="token punctuation">&#125;</span>
	
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="计数排序桶排序基数排序">计数排序、桶排序、基数排序</h2>
<h3 id="计数排序">计数排序</h3>
<p>计数排序(Counting
Sort)是一种O(n)的排序算法，其思路是开一个长度为<code>maxValue-minValue+1</code>的数组，然后</p>
<ol type="1">
<li>分配。扫描一遍原始数组，以当前值-<code>minValue</code>作为下标，将该下标的计数器增1。</li>
<li>收集。扫描一遍计数器数组，按顺序把值收集起来。</li>
</ol>
<p>举个例子，<code>nums=[2, 1, 3, 1, 5]</code>,
首先扫描一遍获取最小值和最大值，<code>maxValue=5</code>, <code>minValue=1</code>，于是开一个长度为5的计数器数组<code>counter</code>，</p>
<ol type="1">
<li>分配。统计每个元素出现的频率，得到<code>counter=[2, 1, 1, 0, 1]</code>，例如<code>counter[0]</code>表示值<code>0+minValue=1</code>出现了2次。</li>
<li>收集。<code>counter[0]=2</code>表示<code>1</code>出现了两次，那就向原始数组写入两个1，<code>counter[1]=1</code>表示<code>2</code>出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为<code>[1,1,2,3,5]</code>，排序好了。</li>
</ol>
<p>计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序。</p>
<p>下面以<a href="https://www.luogu.com.cn/problem/P1059">P1059
[NOIP2006 普及组] 明明的随机数</a>为例来说明其具体实现：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
计数排序 
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> b<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>
		b<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token punctuation">&#125;</span> </code></pre>
<h3 id="桶排序">桶排序</h3>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol type="1">
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 <span class="math inline">\(n\)</span>
个数据均匀的分配到 <span class="math inline">\(k\)</span> 个桶中</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<p>元素分布在桶中：<br />
<img data-src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" /></p>
<p>然后，元素在每个桶中排序：<br />
<img data-src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" /></p>
<p>当输入的数据可以均匀的分配到每一个桶中最快，当输入的数据被分配到了同一个桶中最慢。</p>
<p>以下是具体实现方法：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> b<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> id <span class="token operator">=</span> x<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>
		b<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">++</span>b<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxn<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">sort</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	
<span class="token punctuation">&#125;</span> </code></pre>
<h3 id="基数排序">基数排序</h3>
<p>基数排序（Radix
sort）是一种非比较型的排序算法，最早用于解决卡片排序的问题。</p>
<p>它的工作原理是将待排序的元素拆分为 <span
class="math inline">\(k\)</span>个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第<span
class="math inline">\(k\)</span>关键字进行稳定排序，再对第<span
class="math inline">\(k-1\)</span>关键字进行稳定排序，再对第<span
class="math inline">\(k-2\)</span>关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序。</p>
<figure>
<img data-src="https://oi-wiki.org/basic/images/radix-sort-1.png"
title="一个基数排序的流程" alt="一个基数排序的流程" />
<figcaption aria-hidden="true">一个基数排序的流程</figcaption>
</figure>
<p>这样做的原因是：在数学中,
数位越高,数位值对数的大小的影响就越大。如果要从高位排序,
那么次高位的排序会影响高位已经排好的大小关系.</p>
<p>基数排序需要借助一种 <strong>稳定算法</strong> 完成内层对关键字的排序。</p>
<p>通常而言，基数排序比基于比较的排序算法（比如快速排序）要快。但由于需要额外的内存空间，因此当内存空间稀缺时，原地置换算法（比如快速排序）或许是个更好的选择。</p>
<p>基数排序确定了一个基数<span
class="math inline">\(radix\)</span>，用于确定以<span
class="math inline">\(radix\)</span>进制的方式进行排序。分析可得到其时间复杂度为<span
class="math inline">\(O(n*k)\)</span>，空间复杂度为<span
class="math inline">\(O(n+radix)\)</span>在理论上，当我们选择的<span
class="math inline">\(radix\)</span>越大，<span
class="math inline">\(k\)</span>越小，基数排序的效率会越高。
所以，在实际运用中，我们往往不会用10来做基数。同时，因为<span
class="math inline">\(radix\)</span>越大，其空间复杂度也会变大，所以，要找到一个空间与时间的平衡点。
在32位无符号整型的排序中，我们一般用<span
class="math inline">\(2^8\)</span>来做<span
class="math inline">\(radix\)</span>的值。</p>
<p>下面以<a href="https://www.luogu.com.cn/problem/P1177">洛谷 P1177
【模板】快速排序</a>为例题说明其实现方法，详细部分见注释：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span> </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> cnt<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//桶排的桶</span>
<span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> radix <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//临时数组，用于桶排元素的储存</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//目前的位</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> d <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> d<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//循环次数</span>
    	<span class="token function">memset</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> radix<span class="token punctuation">;</span><span class="token comment">//获取当前位的数字</span>
            cnt<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//记录该数字出现的次数</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> radix<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	        <span class="token comment">/*
	        前缀和处理后，cnt变为当前数字后一个数在构成的序列中的排名。
	        例如 [0, 1, 0, 2, 1, 3]代表 1出现1次, 3出现两次.... // 1 3 3 4 5 5 5
			其前缀和数组为[0, 1, 1, 3, 4, 7] 
	        */</span>
            cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> cnt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">/*
        为保证排序的稳定性，此处循环i应从n到1
  		即当两元素关键字的值相同时，原先排在后面的元素在排序后仍应排在后面
  		*/</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> radix<span class="token punctuation">;</span>
            tmp<span class="token punctuation">[</span><span class="token operator">--</span>cnt<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相当于把tmp中排好序的数列赋给了data，但是比直接复制要快许多。</span>
        p <span class="token operator">*=</span> radix<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        cin <span class="token operator">>></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">radixSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="三者比较">三者比较</h3>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
<h2 id="快速排序归并排序">快速排序、归并排序</h2>
<h2 id="快速排序">### 快速排序</h2>
<p>参考自：<br />
<a href="https://oi-wiki.org/basic/sort-intro/">排序简介</a></p>
<p><a
href="https://soulmachine.gitbooks.io/algorithm-essentials/content/java/sorting/counting-sort/">计数排序</a><br />
<a href="https://www.runoob.com/w3cnote/bucket-sort.html">1.9
桶排序</a><br />
<a href="https://www.runoob.com/w3cnote/radix-sort.html">1.10
基数排序</a><br />
<a href="https://oi-wiki.org/basic/radix-sort/">基数排序</a><br />
<a
href="https://www.luogu.com.cn/blog/MaxDYF/ji-shuo-pai-xu-du-liu-ka-chang">基数排序——毒瘤卡常</a><br />
<a
href="https://www.cnblogs.com/sun/archive/2008/06/26/1230095.html">算法总结系列之五:
基数排序(Radix Sort)</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基础—图</title>
    <url>/posts/46893.html</url>
    <content><![CDATA[<p>关于<strong>深度优先搜索(DFS)</strong>和
<strong>广度优先搜索(BFS)</strong>，不同的书对其有着不同的内容划分，有的将其划分到搜索（如《深入浅出程序设计竞赛—基础篇》），有的将其划分到数据结构基础（如《算法竞赛入门经典》）。不管怎么都是可以的，不过我倾向于在学完<code>数据结构—树</code>以后，将其的思想用到图的搜索上，这样一样和图论的讲解也就更好的衔接。</p>
<p>下面的动图可以帮助你首先有个生动形象的直观理解：<br />
<a
href="https://cs.stanford.edu/people/abisee/tutorial/bfsdfs.html">Comparing
BFS and DFS</a></p>
<h2 id="深度优先搜索">深度优先搜索</h2>
<p>通俗易懂的来说就是：一条路走到黑，不撞南墙不回头。</p>
<p>不过需要<code>注意</code>的是：假如一个方格可能会被多条路径经过，那么在标记其占位并搜索完前面的路径后，需要取消对其的占位标记（即回溯），这样才能让其在此被其他路径所经过。下面介绍几种基本应用：</p>
<p><strong>1. 求路径数</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
洛谷-P1605 迷宫
https://www.luogu.com.cn/problem/P1605
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> t<span class="token punctuation">,</span> sx<span class="token punctuation">,</span> sy<span class="token punctuation">,</span> fx<span class="token punctuation">,</span> fy<span class="token punctuation">;</span>
<span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span> 
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token comment">//边界外或者访问过就返回 </span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>x<span class="token operator">></span>n<span class="token operator">||</span>y<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>y<span class="token operator">></span>m<span class="token punctuation">)</span><span class="token operator">||</span>vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>fx<span class="token operator">&amp;&amp;</span>y<span class="token operator">==</span>fy<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		cnt<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//占位, 防止往回走 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> nx <span class="token operator">=</span> x<span class="token operator">+</span>dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y<span class="token operator">+</span>dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token function">dfs</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//取消占位(回溯), 空出占用的位置 </span>
	<span class="token comment">/*
	# # # $ # 
	. . # . .
	# # . . #
	. . . . #
	# # . . #
	# # @ # #
	*/</span> 
<span class="token punctuation">&#125;</span> 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sy<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fy<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
		vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">dfs</span><span class="token punctuation">(</span>sx<span class="token punctuation">,</span> sy<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token punctuation">&#125;</span> </code></pre>
<p><strong>2. 求连通块个数</strong><br />
<span class="math inline">\(DFS\)</span>和<span
class="math inline">\(BFS\)</span>都可以用于求连通块，都是搜索，<span
class="math inline">\(DFS\)</span>会更加简洁好写，因此基本使用<span
class="math inline">\(DFS\)</span>来求解</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
POJ-2386 Lake Counting 
https://vjudge.net/problem/POJ-2386
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> res<span class="token punctuation">;</span>
<span class="token comment">/*
数组开小了会导致WA：field[nx][ny]超出数组范围 
对此POJ显示WA，而OpenJ_Bailian则显示TLE，发现后者不仅仅对这题如此 
*/</span> 
<span class="token keyword">char</span> field<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	field<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span> <span class="token comment">//将水坑夷为平地, 表示已经搜索过 </span>
	<span class="token comment">//由于水坑的连接四通八达，因此需要将每个方向都进行搜素 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> dx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> dx <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> dx<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> dy <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> dy <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> dy<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> nx <span class="token operator">=</span> x<span class="token operator">+</span>dx<span class="token punctuation">,</span> ny <span class="token operator">=</span> y<span class="token operator">+</span>dy<span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;=</span>nx<span class="token operator">&amp;&amp;</span>nx<span class="token operator">&lt;=</span>n<span class="token operator">&amp;&amp;</span><span class="token number">1</span><span class="token operator">&lt;=</span>ny<span class="token operator">&amp;&amp;</span>ny<span class="token operator">&lt;=</span>m<span class="token operator">&amp;&amp;</span>field<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'W'</span><span class="token punctuation">)</span> 
				<span class="token function">dfs</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span> 
	<span class="token punctuation">&#125;</span>      
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> field<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		 	<span class="token keyword">if</span><span class="token punctuation">(</span>field<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'W'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		 		<span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
		 		res<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span> 
		<span class="token punctuation">&#125;</span> 
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="广度优先搜索">广度优先搜索</h2>
<p>通俗易懂的来说就是：如洪水泛滥般，周围村庄先被殃及</p>
<p>在<code>数据结构—树</code>中讲过了树的广度优先遍历，对于一个节点<span
class="math inline">\(u\)</span>，我们优先遍历其所有的子节点，即靠其最近的节点（距离为1）。那么同样的道理，在图的搜索中，广度优先搜索(BFS)会优先考虑每种状态和初始状态的距离，越近的就会越先考虑。</p>
<p>利用上述特性我们可以求图中的<strong>最短步数</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
POJ-2251 Dungeon Master
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c<span class="token punctuation">,</span> sx<span class="token punctuation">,</span> sy<span class="token punctuation">,</span> sz<span class="token punctuation">;</span>
<span class="token keyword">bool</span> vis<span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> mp<span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
	<span class="token keyword">int</span> step<span class="token punctuation">;</span>
	<span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">,</span> <span class="token keyword">int</span> step<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">step</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> mv<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    queue <span class="token operator">&lt;</span>node<span class="token operator">></span> que<span class="token punctuation">;</span>
    vis<span class="token punctuation">[</span>sx<span class="token punctuation">]</span><span class="token punctuation">[</span>sy<span class="token punctuation">]</span><span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>sx<span class="token punctuation">,</span> sy<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        node now <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>now<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>now<span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>now<span class="token punctuation">.</span>z<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'E'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Escaped in %d minute(s).\n"</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span>step<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        	<span class="token keyword">int</span> nx <span class="token operator">=</span> now<span class="token punctuation">.</span>x<span class="token operator">+</span>mv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> now<span class="token punctuation">.</span>y<span class="token operator">+</span>mv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nz <span class="token operator">=</span> now<span class="token punctuation">.</span>z<span class="token operator">+</span>mv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>nx<span class="token operator">&amp;&amp;</span>nx<span class="token operator">&lt;</span>l<span class="token operator">&amp;&amp;</span><span class="token number">0</span><span class="token operator">&lt;=</span>ny<span class="token operator">&amp;&amp;</span>ny<span class="token operator">&lt;</span>r<span class="token operator">&amp;&amp;</span><span class="token number">0</span><span class="token operator">&lt;=</span>nz<span class="token operator">&amp;&amp;</span>nz<span class="token operator">&lt;</span>c<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">[</span>nz<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>mp<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">[</span>nz<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token char">'#'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                vis<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">[</span>nz<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
                que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> nz<span class="token punctuation">,</span> now<span class="token punctuation">.</span>step<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Trapped!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>l<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>l<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>r<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>c<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> c<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            		vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            		<span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'S'</span><span class="token punctuation">)</span>
						sx <span class="token operator">=</span> i<span class="token punctuation">,</span> sy <span class="token operator">=</span> j<span class="token punctuation">,</span> sz <span class="token operator">=</span> k<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>	
			<span class="token punctuation">&#125;</span>
        <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="总结">总结</h2>
<p>以上分别介绍了深度优先搜索(DFS)和
广度优先搜索(BFS)不同的基本应用，我们需要根据题目的性质来灵活的决定使用哪种搜索方式。</p>
<hr />
<p>参考自：<br />
<a href="https://zhuanlan.zhihu.com/p/70802487">BFS,DFS,A* and
Dijkstra's的区别与联系</a><br />
<a href="../images/NOI暑假培训/算法专题/图论/Graph%20Search.pdf">Graph
Search Algorithms</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基础—栈、队列、链表</title>
    <url>/posts/56729.html</url>
    <content><![CDATA[<h2 id="前言为什么我们需要数据结构">前言—为什么我们需要数据结构</h2>
<p>我们需要数据结构呢？
为什么要设计这么多数据结构？数据结构到底解决了我们什么样的问题？</p>
<p>我们提到数据结构时，一般是指计算机科学中的一个概念，
但是从本质上讲，数据结构应该是指对数据的一种组织方式。既然如此，我们没必要非在计算机科学领域中讨论
概念本身，把它放在其它领域中，可能更能加强我们的理解。</p>
<p>就说图书管吧，假如你是一名很久很久以前的图书馆管理员，那时候根本没什么计算机。数据结构？那是什么？</p>
<p>你的任务就是看着图书馆里的一堆书。于是，有一天，图书馆来了一堆书，你把他们堆成一堆，放在馆里。
这时候，有人来借书了，他只能在那一堆书里乱翻，翻来翻去也找不到自己想要的书，因为那是一堆书，
有的书他检查了很多次，有的一次也没检查。</p>
<blockquote>
<p>这时候这堆书是一个集合，不方便遍历。</p>
</blockquote>
<p>时间长了，抱怨的人很多。</p>
<p>作为一个怕麻烦的管理员，你忍受不了别人的抱怨，于是，你把那 <strong>一堆书</strong> 变成了 <strong>一排书</strong>。</p>
<p>这下好了，来找书的人，只要从书架左边走到右边，按顺序找就好了。只要书在图书馆里，慢慢找总是可以找到。
但是，随着图书馆的书越来越多，这样找实在是太慢了，因为每次都要从第一本书找到最后一本书。</p>
<blockquote>
<p>这时候这堆书是一个列表，方便遍历，但是不方便查找。</p>
</blockquote>
<p>时间长了，抱怨的人很多。</p>
<p>作为一个怕麻烦的管理员，你忍受不了别人的抱怨，于是，你把那 <strong>一排书</strong> 变成了 <strong>很多类书</strong>。</p>
<p>那么，按什么分类呢？按书的大小么？颜色么？退一步讲，分类的依据是什么？</p>
<p>分类是为了加快读者查找书的速度，那么读者查找书的时候，是按什么查找呢？是按书名。所以，我们对书名分类。
按书名分类也有许多种，按书名读音么？按书名笔画吗？按书名字数么？我们很容易想到，按读音分类给读者的压力最小，
也就是查找前的开销最小。否则每次找书之前还要数一下笔画，读者一定又会抱怨。</p>
<p>这时候，我们按读音把书分类，书名第一个字是A的在A书架，是B的在B书架。这下读者查找书的速度大大加快了，
因为一下子就能排除那么多类书，而代价仅仅是想一下书名第一个字的读音。不过，我们马上又发现，有的书架上书实在太多了，
那有什么关系？这个问题我们解决过啊，只要再分类就好了，书名第一个字我们用过了，现在用第二个字。</p>
<p>读者终于大致可以满意了。</p>
<blockquote>
<p>这时候这些书架构成了一个查找树，方便查找。</p>
</blockquote>
<p>另外，我们注意到，其实对于管理员来说，他的负担是增加了的，比如新来了一本书，如果图书馆是一堆书，
只要把新书扔在那一堆里就好了，如果是一排书，要把新书放在这排书的最后，而如果是分好类的书架，
管理员就要先找到这本书的位置，再把新书放在那儿，而不能随便放。好在分类后，我们找新书位置不会花多久，
假如分好类后，读者查找书方便了，但是管理员要把新书放在合适的位置，需要花一年时间，
那这个分类的方法肯定不是一个好方法。</p>
<p>这告诉我们</p>
<blockquote>
<p>维护数据结构很重要。</p>
</blockquote>
<h2 id="栈">栈</h2>
<p>栈是一种“先进后出”的线性数据结构，其只能在一端进行插入和删除操作。我们可以使用一个数组和一个变量（记录栈顶位置）来实现栈结构。</p>
<p>下面UVA-514 Rails、UVA-673 Parentheses Balance为例说明基础应用：</p>
<p><a href="https://vjudge.net/problem/UVA-514">UVA-514 Rails</a><br />
思考过程如下图和代码注释所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/数据结构/模拟栈.png" /></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
目标序列可按照进栈顺序1~n出栈形成，需判断目标序列是否合理 
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> target<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>
			<span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> B <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token comment">//注意输入细节 </span>
			<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>target<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> ok <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span><span class="token punctuation">(</span>B<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token comment">//下面两行if和else if判断目标编号是否匹配栈顶元素</span>
				<span class="token comment">//栈顶元素可以是当前的栈顶，也可以进栈元素压栈后成为新的栈顶 </span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token operator">==</span>target<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">)</span> 
					A<span class="token operator">++</span><span class="token punctuation">,</span> B<span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>target<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">)</span>
					s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> B<span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token comment">//不匹配则可以进栈 </span>
				<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span>
					s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>A<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//若无元素进栈且又找不到目标编号说明编号顺序不合理 </span>
				<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
					ok <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> ok<span class="token operator">?</span><span class="token string">"Yes"</span><span class="token operator">:</span><span class="token string">"No"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">//注意格式 </span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><a href="https://vjudge.net/problem/UVA-673">UVA-673 Parentheses
Balance</a></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 
使用栈判断括号序列是否合理 
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stack></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e5</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token keyword">char</span> s<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    cin <span class="token operator">>></span> n<span class="token punctuation">;</span> 
	<span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> stk<span class="token punctuation">;</span>
        <span class="token function">gets</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token char">'('</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">')'</span><span class="token operator">||</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token char">'['</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">']'</span><span class="token punctuation">)</span>
                stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yes"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"No"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="表达式的计算">表达式的计算</h3>
<p>栈对求表达式求值有着特殊的作用，以<a
href="https://vjudge.net/problem/UVA-442">UVA-442 Matrix Chain
Multiplication</a>为例说明：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
计算表达式 
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span> </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Matrix</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
	<span class="token function">Matrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>m<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
stack<span class="token operator">&lt;</span>Matrix<span class="token operator">></span> s<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n<span class="token punctuation">;</span>
	cin <span class="token operator">>></span> n<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">char</span> name<span class="token punctuation">;</span>
		cin <span class="token operator">>></span> name<span class="token punctuation">;</span>
		<span class="token keyword">int</span> k <span class="token operator">=</span> name <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">;</span>
		cin <span class="token operator">>></span> m<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>a <span class="token operator">>></span> m<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	string expr<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>expr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> len <span class="token operator">=</span> expr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">bool</span> error <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token char">'A'</span><span class="token operator">&lt;=</span>expr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>expr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token char">'Z'</span><span class="token punctuation">)</span>
				s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span>expr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'A'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>expr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				Matrix m2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				Matrix m1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span>b<span class="token operator">!=</span>m2<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					error <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				ans <span class="token operator">+=</span> m1<span class="token punctuation">.</span>a<span class="token operator">*</span>m1<span class="token punctuation">.</span>b<span class="token operator">*</span>m2<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
				s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">Matrix</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span>a<span class="token punctuation">,</span> m2<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="队列">队列</h2>
<p>队列是一种“先进先出的”线性数据结构，一般来说，元素从左端进入队列，需从右端离开队列。我们称队列的左端为队头,右端为队尾。可以在C++中用一个数组和两个变量（记录队头和队尾的位置）来实现队列结构。</p>
<p>元素进行多次入队、出队后，用于实现队列结构的数组的开头部分空间就会被严重浪费，所以我们经常将其优化为“循环队列”，也就是把队列看作一个首尾相接的环，只要队列中的元素个数在任意时刻都不超过环长,那么随着入队和出队操作的进行,存储元素的那一段位置就像沿着环不停地移动，重复利用着历史上曾被占用过的空间。C++
STL中的queue就是一个循环队列，也是我们在代码中最常见的队列实现方式。</p>
<p>下面分别以<a href="https://vjudge.net/problem/UVA-540">UVA-540 Team
Queue</a>为例说明其基础应用：</p>
<p>我们用队列数组存储每一个小团队的队列，然后再加一个队列来存储各个团队的队列</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
有 t 个小组排队，每个小组有若干人.
当一个人入队时，如果队伍中已有与他同一队伍的人，那么这个人就插到同一队伍人的最后，否则插到队伍最后.
先给出若干入队和出队指令，要求输出出队顺序.
*/</span> 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> team<span class="token punctuation">[</span><span class="token number">10000100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> t<span class="token punctuation">,</span> num<span class="token punctuation">,</span> x<span class="token punctuation">,</span> ca <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Scenario #%d\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> t<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>num<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                team<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'S'</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'E'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>team<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>team<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//q[0]队列用于记录当前操作的队伍编号 </span>
                q<span class="token punctuation">[</span>team<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'D'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            	<span class="token keyword">int</span> top <span class="token operator">=</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//上个入队的队伍编号 </span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                q<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</code></pre>
<h2 id="链表">链表</h2>
<p>链表相较于数组来说，可以更加灵活的进行修改操作(插入和删除)，只需要花费O(1)的时间，但是查找就需要O(n)的时间，其适用于在修改操作频繁的要求。因此我们要学会根据需求灵活选择适合的数据结构。</p>
<p>下面分别以<a href="https://vjudge.net/problem/UVA-11988">UVA-11988
Broken Keyboard</a>为例说明其基础应用：</p>
<p>这题开始想着可以用思维法做，但是尝试过后发现中括号[]之间还可以叠加中括号[]和穿插字符，这让处理变得有些麻烦，还不如用链表直观简单</p>
<p>使用STL库：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
list<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> l<span class="token punctuation">;</span>
string str<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        l<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'['</span><span class="token punctuation">)</span> it <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">']'</span><span class="token punctuation">)</span> it <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> l<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>it <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>模拟链表的方法：<br />
<img data-src="../images/NOI暑假培训/算法专题/数据结构/模拟链表插入1.png" /><br />
<img data-src="../images/NOI暑假培训/算法专题/数据结构/模拟链表插入2.png" /></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span> </span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e5</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> last<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> nxt<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token keyword">char</span> s<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		last <span class="token operator">=</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
		nxt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//链表的头节点 </span>
		<span class="token comment">// cur用于记录新节点插入链表的位置 </span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">char</span> ch <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token char">'['</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token char">']'</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> last<span class="token punctuation">;</span>
			<span class="token comment">//模拟链表插入操作 </span>
			<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nxt<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//第一步 </span>
				nxt<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">//第二步 </span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">==</span>last<span class="token punctuation">)</span> last <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">//若在尾部插入则更新尾id的标记 </span>
				cur <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">//第三步(移动光标) </span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">//链表输出</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nxt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">=</span> nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"%c"</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
</code></pre>
<hr />
<p>参考自：<br />
<a
href="http://minixalpha.github.io/%E6%80%9D%E6%83%B3/2013/10/26/whyds.html">为什么我们需要数据结构</a><br />
《深入浅出程序设计竞赛（基础篇）》<br />
《算法竞赛入门经典》<br />
《算法竞赛进阶指南》</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基础—树</title>
    <url>/posts/23439.html</url>
    <content><![CDATA[<p>树作为一种基本的数据结构，不管是在各类信息学，还是在各种系统、工程问题中使用都十分广泛。但是时间有限，不能将其讲的面面俱到，目前掌握基础的常用做法就可，而信息学中二叉树的使用较为频繁。</p>
<h2 id="二叉树的建立与编号">二叉树的建立与编号</h2>
<p>计算机是人类发明的，因此所有相关的原理我们都可以相较其他自然学科更好的推测理解。</p>
<p>建立和记录一颗二叉树的信息我们有很多种方式，只要合理且对场景使用就是最好的方式。下面来介绍几种常见的方式，后面的题目中你也能见到它们各自的应用。</p>
<ol type="1">
<li>数组实现二叉树信息存储与索引</li>
</ol>
<ul>
<li><p>当前节点为<span class="math inline">\(u\)</span>,
将其左右子节点信息存储在<span
class="math inline">\(tree[2*u]\)</span>和<span
class="math inline">\(tree[2*u+1]\)</span>中。但是这种方式耗费空间较大，若二叉树深度为<span
class="math inline">\(n\)</span>，则需要建立大小为<span
class="math inline">\(2^n\)</span>的数组，会耗费较大的空间，尤其是当树退化成一条链的时候</p></li>
<li><p>当前节点为<span class="math inline">\(u\)</span>,
将其左右子节点信息存储在<span
class="math inline">\(left[u]\)</span>和<span
class="math inline">\(right[u]\)</span>中</p></li>
</ul>
<ol start="2" type="1">
<li><p>结构体数组实现二叉树信息存储与索引，例如： <pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>tree<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></p></li>
<li><p>指针实现二叉树信息索引，例如： <pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> v<span class="token punctuation">;</span><span class="token comment">//结点值</span>
    node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></p></li>
</ol>
<p>以<a
href="https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P4913">洛谷-P4913
二叉树深度</a>为基础例子说明，在后面的题目中会有不同的做法并附上详细的解释</p>
<p>方法一：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
当前节点为u, 使用2*u, 2*u+1分别表示左右子节点
二叉树深度为n，则需要建立大小为2^n的数组, 需要较大的空间 
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e6</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> tree<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> ans<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> deep<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//到达叶子节点时返回</span>
    ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> deep<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//更新答案</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token punctuation">]</span><span class="token punctuation">,</span> deep<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向左子树遍历</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> deep<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向右子树遍历</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>
    <span class="token comment">//读入数据并建树</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
   		cin <span class="token operator">>></span> tree<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">]</span> <span class="token operator">>></span> tree<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从1号节点出发，当前深度为1</span>
    cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</code></pre>
<p>方法二：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
使用结构体node来表示当前节点存储的信息 
*/</span> 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e6</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>tree<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> ans<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> deep<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>id<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span> 
    ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> deep<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">,</span> deep<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">,</span> deep<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
   		cin <span class="token operator">>></span> tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">>></span> tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="二叉树的层次遍历">二叉树的层次遍历</h2>
<p>从根节点开始，按照一层层的顺序从左到右遍历输出所有节点的遍历方式就叫做二叉树的层次遍历，如下图：<br />
<img data-src="../images/NOI暑假培训/算法专题/数据结构/二叉树层次遍历.jpg" /></p>
<p>二叉树的层次遍历通过队列可以实现，以<a
href="https://vjudge.net/problem/UVA-122">UVA-122 Trees on the
level</a>为例说明：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">256</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> s<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//保存读入的节点</span>
<span class="token keyword">bool</span> failed<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">bool</span> have_value<span class="token punctuation">;</span><span class="token comment">//是否被赋值过</span>
    <span class="token keyword">int</span> v<span class="token punctuation">;</span><span class="token comment">//结点值</span>
    node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
    <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">have_value</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//构造函数初始化 </span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
node <span class="token operator">*</span>root<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">remove_tree</span><span class="token punctuation">(</span>node<span class="token operator">*</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>
    <span class="token function">remove_tree</span><span class="token punctuation">(</span>u<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归释放左子树的空间</span>
    <span class="token function">remove_tree</span><span class="token punctuation">(</span>u<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span>
    <span class="token keyword">delete</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
node<span class="token operator">*</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">addNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token operator">*</span> u <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token comment">//从根节点往下走</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//找到当前位置</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'L'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">-></span>left<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> u<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//节点不存在 建立新节点</span>
            u <span class="token operator">=</span> u<span class="token operator">-></span>left<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'R'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">-></span>right<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> u<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            u <span class="token operator">=</span> u<span class="token operator">-></span>right<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//忽略其他情况，即最后多余的那个右括号</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">-></span>have_value<span class="token punctuation">)</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//已经赋过值 表明输入有误</span>
    u<span class="token operator">-></span>v <span class="token operator">=</span> v<span class="token punctuation">;</span><span class="token comment">//给节点赋值 </span>
    u<span class="token operator">-></span>have_value <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//标记已经赋值</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//读入字符</span>
<span class="token keyword">bool</span> <span class="token function">read_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//记录是否输入有误</span>
    <span class="token comment">//输入新数据时原先的内存不会再使用，从专业角度来说最好释放内存空间以防止内存泄漏 </span>
    <span class="token comment">//内存泄漏指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果 </span>
    <span class="token function">remove_tree</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建根节点</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//整个输入结束</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token string">"()"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//读到结束标志 退出循环</span>
        <span class="token keyword">int</span> v<span class="token punctuation">;</span>
        <span class="token function">sscanf</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读入节点值</span>
        <span class="token function">addNode</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token function">strchr</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// strchr函数功能为在一个串中查找给定字符的第一个匹配之处</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
    这样一来 输入和建树部分就已经结束了  接下来只需要按照层次顺序遍历这棵树
    此处使用一个队列来完成这个任务  初始时只有一个根节点  然后每次取出一个节点
    就把它的左右子结点放入队列中
*/</span>
<span class="token keyword">bool</span> <span class="token function">bfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    queue<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>
    ans<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始时只有一个根节点</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        node<span class="token operator">*</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>u<span class="token operator">-></span>have_value<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//有节点没有被赋值过 表明输入有误</span>
        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token operator">-></span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//增加到输出序列尾部</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">-></span>left<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>u<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">-></span>right<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>u<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>failed<span class="token operator">||</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">bfs</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"not complete\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">,</span> it<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>it<span class="token punctuation">;</span> it<span class="token operator">!=</span>ans<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %d"</span><span class="token punctuation">,</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong><em>为什么结点有时要用指针实现？</em></strong></p>
<p><em>使用数组或是指针来进行索引，功能上是等同的。</em><br />
<em>但如果用数组表示，会有一个问题：</em><br />
<em>数组是在定义时候确定大小，并且以后无法改变的；如果在编制程序之初无法确定有多少个节点，怎么办？
而指针在使用上则更为简单。因此，具体的设计中，会倾向于使用指针。</em></p>
<p>而二叉树并不一定要用指针实现，作为OI或者ACM选手，使用数组对于我们来说更加的方遍。接下来，把指针完全去掉。首先还是给每个结点编号，但不是按照从上到下从左到右的顺序，而是按照结点的生成顺序。用计数器<code>cnt</code>表示已存在的
结点编号的最大值，因此<code>newnode</code>函数需要改成这样：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> root <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">newtree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	left<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	have_value<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	cnt <span class="token operator">=</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token operator">++</span>cnt<span class="token punctuation">;</span>
	left<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	have_value<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>上面的<code>newtree()</code>是用来代替前面的<code>remove_tree(root)</code>和<code>root = newnode()</code>两条语句的。由于没有了动态内存的申请和释放，只需要重置结点计数器和根结点的左右子树了。</p>
<p>当然这题还有一种更妙的方式：若当前节点为<code>str</code>，其左右子节点的信息存到<code>mp[str+"L"]</code>和<code>mp[str+"R"]</code>中：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
二叉树的层次遍历 
ref:
https://gist.github.com/OmarSRehan/eebe2ab5659324bf7052189d8adb7633
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>
<span class="token comment">/*
类似把第i个节点的左右子树信息存到tree[2*i]和tree[2*i+1]中
这里把名称为str节点左右子树的信息存到mp[str+"L"]和mp[str+"R"]中 
*/</span>
<span class="token keyword">int</span> cnt<span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">310</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//层次遍历 </span>
<span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span>string root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    queue<span class="token operator">&lt;</span>string<span class="token operator">></span> q<span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		string cur <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//若找到对应的结点则将其子节点放入队列 </span>
		<span class="token comment">//(3, L), (4, R)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        	res<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> mp<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>
            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">+</span><span class="token string">"L"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">+</span><span class="token string">"R"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    string s<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">!=</span><span class="token string">"()"</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//(11, LL)</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            string r<span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token char">','</span><span class="token punctuation">)</span> t <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
            r <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">==</span>mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> mp<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> mp<span class="token punctuation">[</span><span class="token string">"X"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//标记一个节点被多次赋予一个值</span>
        <span class="token punctuation">&#125;</span> 
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">==</span>mp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            	cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> cnt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            		cout <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> 
			<span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"not complete"</span><span class="token punctuation">;</span>
            cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            mp<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="二叉树的深度优先遍历">二叉树的深度优先遍历</h2>
<p>给定任意节点，可以访问该节点本身、遍历左子树、遍历右子树，这就叫做如二叉树的深度优先遍历，如下图所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/数据结构/二叉树深度优先遍历.jpg" /><br />
根据在某个节点中比哪里的顺序不同，有以下3种遍历方式：</p>
<ul>
<li><strong>中序遍历：</strong> 左子树-&gt; 根结点 -&gt; 右子树<br />
（先访问左子树，再访问根节点，后访问右子树，而对于每个子树来说，又按照同样的访问顺序进行遍历）</li>
<li><strong>先序遍历：</strong> 根结点 -&gt; 左子树 -&gt; 右子树</li>
<li><strong>后序遍历：</strong> 左子树 -&gt; 右子树 -&gt; 根结点</li>
</ul>
<p>根据三种遍历的特性，递归的算法很容易就能写出来：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//先序</span>
<span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>node <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> root<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>lch<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>rch<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//中序</span>
<span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>node <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token function">InOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>lch<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> root<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">InOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>rch<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//后序</span>
<span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>node <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token function">PostOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>lch<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PostOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>rch<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> root<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong>利用二叉树的深度优先遍历我们可以做到很多事情，如由两种遍历确定一颗二叉树、求二叉树的高度等等</strong>，这里以<a
href="https://vjudge.net/problem/UVA-548">UVA-548
Tree</a>说明上述两种应用：</p>
<p>需注意的是，必须要有中序，否则无法确定，例如前序+后序，此时无法确定这颗树是何种形态：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">  A 和 A 
 <span class="token operator">/</span>      \ 
B        B</code></pre>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
后序+中序确定一颗二叉树
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sstream></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">inf</span> <span class="token expression"><span class="token number">0x3f3f3f3f</span> </span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token comment">//因为各个结点的权值各不相同且都是正整数，直接用权值作为结点编号 </span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token number">10000</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> n<span class="token punctuation">,</span> in_order<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">,</span> post_order<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> lch<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">,</span> rch<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">read_list</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	string order<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> order<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	stringstream <span class="token function">ss</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>
	n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>ss<span class="token operator">>></span>x<span class="token punctuation">)</span> a<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> 
<span class="token comment">//把in_order[L1..r1]和post_order[l2..r2]建成一棵二叉树，返回树根</span>
<span class="token keyword">int</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> l1<span class="token punctuation">,</span> <span class="token keyword">int</span> r1<span class="token punctuation">,</span> <span class="token keyword">int</span> l2<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token operator">></span>r1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//空树</span>
	<span class="token keyword">int</span> root <span class="token operator">=</span> post_order<span class="token punctuation">[</span>r2<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> l1<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>in_order<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">!=</span>root<span class="token punctuation">)</span> p<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> cnt <span class="token operator">=</span> p<span class="token operator">-</span>l1<span class="token punctuation">;</span> <span class="token comment">//左子树的结点个数</span>
	lch<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> l2<span class="token punctuation">,</span> l2<span class="token operator">+</span>cnt<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	rch<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> l2<span class="token operator">+</span>cnt<span class="token punctuation">,</span> r2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> best<span class="token punctuation">,</span> best_sum<span class="token punctuation">;</span> <span class="token comment">//目前为止的最优解和对应的权和</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	sum <span class="token operator">+=</span> u<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>lch<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>rch<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//叶子</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">&lt;</span>best_sum<span class="token operator">||</span><span class="token punctuation">(</span>sum<span class="token operator">==</span>best_sum<span class="token operator">&amp;&amp;</span>u<span class="token operator">&lt;</span>best<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			best <span class="token operator">=</span> u<span class="token punctuation">;</span>
			best_sum <span class="token operator">=</span> sum<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>lch<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>lch<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>rch<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>rch<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read_list</span><span class="token punctuation">(</span>in_order<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">read_list</span><span class="token punctuation">(</span>post_order<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">build</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		best_sum <span class="token operator">=</span> inf<span class="token punctuation">;</span>
		<span class="token function">dfs</span><span class="token punctuation">(</span>post_order<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> best <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>这题需要特别注意输入，否则会TLE，需要使用getline()来判断是否到文件末尾</p>
<h2 id="总结">总结</h2>
<p>关于树的建立、层次遍历、深度优先遍历的基本概念和应用讲解完毕，将来这些思想还会在图或者其他类型题目上有更深的应用，有了这些基础将来可以自行探索。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数论—常见符号</title>
    <url>/posts/6401.html</url>
    <content><![CDATA[<h3 id="整除同余理论常见符号">整除/同余理论常见符号</h3>
<ol type="1">
<li>整除符号：<span class="math inline">\(x\mid y\)</span>，表示 <span
class="math inline">\(x\)</span> 整除 <span
class="math inline">\(y\)</span>，即 <span
class="math inline">\(x\)</span> 是 <span
class="math inline">\(y\)</span> 的因数。</li>
<li>取模符号：<span class="math inline">\(x\bmod y\)</span>，表示 <span
class="math inline">\(x\)</span> 除以 <span
class="math inline">\(y\)</span> 得到的余数。</li>
<li>互质符号：<span class="math inline">\(x\perp y\)</span>，表示 <span
class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>
互质。</li>
<li>最大公约数：<span
class="math inline">\(\gcd(x,y)\)</span>，在无混淆意义的时侯可以写作<span
class="math inline">\((x,y)\)</span></li>
<li>最小公倍数：<span
class="math inline">\(\operatorname{lcm}(x,y)\)</span>，在无混淆意义的时侯可以写作<span
class="math inline">\([x,y]\)</span></li>
</ol>
<h3 id="数论函数常见符号">数论函数常见符号</h3>
<p>求和符号：<span class="math inline">\(\sum\)</span>
符号，表示满足特定条件的数的和。举个例子：</p>
<ul>
<li><span class="math inline">\(\sum_{i=1}^n i\)</span> 表示 <span
class="math inline">\(1+2+\dotsb+n\)</span> 的和。</li>
</ul>
<p>求积符号：<span class="math inline">\(\prod\)</span>
符号，表示满足特定条件的数的积。举几个例子：</p>
<ul>
<li><span class="math inline">\(\prod_{i=1}^ni\)</span> 表示 <span
class="math inline">\(n\)</span> 的阶乘，即 <span
class="math inline">\(n!\)</span>。在组合数学常见符号中会讲到。</li>
<li><span class="math inline">\(\prod_{i=1}^na_i\)</span> 表示 <span
class="math inline">\(a_1\times a_2\times a_3\times \dotsb\times
a_n\)</span>。</li>
<li><span class="math inline">\(\prod_{x|d}x\)</span> 表示 <span
class="math inline">\(d\)</span> 的所有因数的乘积。</li>
</ul>
<p>在行间公式中，求和符号与求积符号的上下条件会放到符号的上面和下面。</p>
<h3 id="其他常见符号">其他常见符号</h3>
<ol type="1">
<li>阶乘符号 <span class="math inline">\(!\)</span>，<span
class="math inline">\(n!\)</span> 表示 <span
class="math inline">\(1\times 2\times 3\times \dotsb \times
n\)</span>。特别地，<span class="math inline">\(0!=1\)</span>。</li>
<li>向下取整符号：<span class="math inline">\(\lfloor
x\rfloor\)</span>，表示小于等于 <span class="math inline">\(x\)</span>
的最大的整数。常用于分数，比如分数的向下取整 <span
class="math inline">\(\left\lfloor\frac{x}{y}\right\rfloor\)</span>。</li>
<li>向上取整符号：<span class="math inline">\(\lceil
x\rceil\)</span>，与向下取整符号相对，表示大于等于 <span
class="math inline">\(x\)</span> 的最小的整数。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>数论—基础</title>
    <url>/posts/10589.html</url>
    <content><![CDATA[<h2 id="约数与倍数">约数与倍数</h2>
<p>若整数<span class="math inline">\(n\)</span>除以整数<span
class="math inline">\(d\)</span>的余数为0，即<span
class="math inline">\(d\)</span>能整除<span
class="math inline">\(n\)</span>，则称<span
class="math inline">\(d\)</span>是<span
class="math inline">\(n\)</span>的约数。<span
class="math inline">\(n\)</span>是<span
class="math inline">\(d\)</span>的倍数，记为<span
class="math inline">\(d | n\)</span></p>
<h3 id="求n的正约数集合试除法">求N的正约数集合—试除法</h3>
<p>若<span class="math inline">\(d \leq \sqrt{N}\)</span>是<span
class="math inline">\(N\)</span>的约数，则<span
class="math inline">\(N/d \geq\sqrt{N}\)</span>也是<span
class="math inline">\(N\)</span>的约数，约数总是成对出现的（除了完全平方数）。因此我们只需要枚举到<span
class="math inline">\(\sqrt{N}\)</span>就能求出所有的因数：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">*</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		fac<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span><span class="token operator">=</span>n<span class="token operator">/</span>i<span class="token punctuation">)</span> fac<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token operator">/</span>i<span class="token punctuation">;</span><span class="token comment">//防止i=n/i出现重复 </span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> 
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> cnt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> fac<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<h3 id="求1n的正约数集合倍数法">求1~N的正约数集合—倍数法</h3>
<p>使用试除法，复杂度为<span
class="math inline">\(O(N\sqrt{N})\)</span>。可以反过来考虑，对于每个数<span
class="math inline">\(d\)</span>，<span class="math inline">\(1\sim
N\)</span>以<span class="math inline">\(d\)</span>为约数的数就是<span
class="math inline">\(d\)</span>的倍数<span
class="math inline">\(d,2d,3d \cdots, \lfloor N/d\rfloor *
d\)</span></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token operator">/</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		fac<span class="token punctuation">[</span>i<span class="token operator">*</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> fac<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> fac<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<p>其时间复杂度为<span class="math inline">\(O(N+N/2+N/3+\cdots
+N/N)=O(N\ logN)\)</span>，和其他复杂度的比较图如下所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/时间复杂度.png" /></p>
<h2 id="最大公约数与最小公倍数">最大公约数与最小公倍数</h2>
<p>若自然数<span class="math inline">\(d\)</span>同时是自然数<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的约数，则称<span
class="math inline">\(d\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公约数。在所有<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公约数中最大的一个，称<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的最大公约数，记为<span
class="math inline">\(gcd(a, b)\)</span></p>
<p>若自然数<span class="math inline">\(m\)</span>同时是自然数<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的倍数，则称<span
class="math inline">\(m\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公倍数。在所有<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公倍数中最小的一个，称<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的最小公倍数，记为<span
class="math inline">\(lcm(a, b)\)</span></p>
<p><strong>定理一</strong><br />
<span class="math display">\[\forall a, b\in\mathbb{N} \qquad
gcd(a,b)*lcm(a, b) = a*b\]</span></p>
<p><strong>定理二（欧几里得算法）</strong><br />
<span class="math display">\[\forall a, b\in\mathbb{N},b\neq 0 \qquad
gcd(a,b)=gcd(b, a \ mod\ b)\]</span></p>
<p>具体实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> b <span class="token operator">?</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token operator">%</span>b<span class="token punctuation">)</span><span class="token operator">:</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="不定方程">不定方程</h3>
<p>考虑解决最简单的不定方程，形如<span
class="math inline">\(ax+by=c\)</span>的二元一次不定方程，其中<span
class="math inline">\(a,b,c\)</span>都是整数</p>
<p><strong>定理一（裴蜀定理）</strong><br />
对于整数<span class="math inline">\(a,b\)</span>，若<span
class="math inline">\(gcd(a, b) = d\)</span>，一定存在一组<span
class="math inline">\((x, y)\)</span>使得<span
class="math inline">\(ax+by=d\)</span></p>
<p>那么该如何通过裴蜀定理解决<span
class="math inline">\(ax+by=c\)</span>这类不定方程问题呢？</p>
<p><strong>定理二</strong><br />
对于整数<span class="math inline">\(a,b,c\)</span>，<span
class="math inline">\(ax+by=c\)</span>有整数解当且仅当<span
class="math inline">\(\gcd(a,b)\mid c\)</span></p>
<p>其充分必要性证明如下：</p>
<ul>
<li>充分性<br />
若<span class="math inline">\(c\)</span>为<span
class="math inline">\(\gcd(a,b)\)</span>的整数倍，即<span
class="math inline">\(c=k*\gcd(a,b)\)</span>，那么可以先通过裴蜀定理找到<span
class="math inline">\(ax+by=\gcd(a,b)\)</span>的一组解<span
class="math inline">\((x,y)\)</span>，易得<span
class="math inline">\((kx,ky)\)</span>为方程<span
class="math inline">\(ax+by=c\)</span>的一组解。</li>
<li>必要性<br />
若不定方程有解，又已知<span class="math inline">\(a\)</span>为<span
class="math inline">\(\gcd(a,b)\)</span>的倍数，<span
class="math inline">\(b\)</span>为<span
class="math inline">\(\gcd(a,b)\)</span>的倍数，则<span
class="math inline">\(c=ax+by\)</span>也一定是<span
class="math inline">\(\gcd(a,b)\)</span>的倍数。</li>
</ul>
<h4 id="求解不定方程axbygcdab">求解不定方程ax+by=gcd(a,b)</h4>
<p>现在有两个问题：</p>
<ol type="1">
<li>如何得到方程的特解？</li>
<li>如何由方程的特解得到其通解？</li>
</ol>
<p>下面解释方程<span
class="math inline">\(ax+by=\gcd(a,b)\)</span>的求解过程：</p>
<h5 id="求方程的特解">求方程的特解</h5>
<p>设<br />
<span class="math inline">\(ax_1+by_1=\gcd(a,b)\)</span><br />
<span class="math inline">\(bx_2+(a\bmod b)y_2=\gcd(b,a\bmod
b)\)</span><br />
由欧几里得定理可知：<span class="math inline">\(\gcd(a,b)=\gcd(b,a\bmod
b)\)</span><br />
所以 <span class="math inline">\(ax_1+by_1=bx_2+(a\bmod
b)y_2\)</span><br />
又因为 <span class="math inline">\(a\bmod
b=a-(\lfloor\frac{a}{b}\rfloor\times b)\)</span><br />
所以 <span
class="math inline">\(ax_1+by_1=bx_2+(a-(\lfloor\frac{a}{b}\rfloor\times
b))y_2\)</span><br />
<span
class="math inline">\(ax_1+by_1=ay_2+bx_2-\lfloor\frac{a}{b}\rfloor\times
by_2=ay_2+b(x_2-\lfloor\frac{a}{b}\rfloor y_2)\)</span><br />
因为 <span class="math inline">\(a=a,b=b\)</span>，所以 <span
class="math inline">\(x_1=y_2,y_1=x_2-\lfloor\frac{a}{b}\rfloor
y_2\)</span></p>
<p>将 <span class="math inline">\(x_2,y_2\)</span>
不断代入递归求解直至解出<span class="math inline">\(\gcd\)</span>，当
<code>b==0</code> 时<code>gcd(a,b)=a</code> ，而易得<code>x=1,y=0</code>
是方程<span
class="math inline">\(ax+by=gcd(a,b)\)</span>其中的一组解，递归回去求解即可。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//ax+by=gcd(a,b) -> (x, y)</span>
<span class="token keyword">int</span> <span class="token function">exgcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">//ax+by=gcd(a,b) 此时gcd(a,b)=a, x=1, y=0是方程的一个解</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	    y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">//bx+(a%b)y=gcd(b,a%b) -> (x, y)</span>
	<span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//x1=y2, y1=x2-(a/b)y2</span>
	<span class="token keyword">int</span> t <span class="token operator">=</span> x<span class="token punctuation">;</span>
	x <span class="token operator">=</span> y<span class="token punctuation">;</span>
	y <span class="token operator">=</span> t <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> y<span class="token punctuation">;</span>
	<span class="token keyword">return</span> d<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h5 id="求方程的通解">求方程的通解</h5>
<p>若有<span class="math inline">\(ax+by=c\)</span>且<span
class="math inline">\(a_0x+b_0y=c\)</span></p>
<p>那么便有<span class="math inline">\(a(x-x_0)+b(y-y_0)=0\)</span></p>
<p>两边同时除以<span
class="math inline">\(\gcd(a,b)\)</span>可得：<br />
<span
class="math display">\[\frac{a}{gcd(a,b)}(x-x_0)=-\frac{b}{gcd(a,b)}(y-y_0)
\tag 1\]</span></p>
<p>而因为<br />
<span
class="math display">\[(\frac{a}{gcd(a,b)},\frac{b}{gcd(a,b)})=1\]</span></p>
<p>所以由(1)可得<br />
<span class="math display">\[\frac{b}{gcd(a,b)} \mid
(x-x_0)\]</span></p>
<p>所以很显然有<br />
<span class="math display">\[\frac{b}{gcd(a,b)}\times{t}={(x-x_0)},t \in
Z\]</span></p>
<p>那么就有对于任意一个<span
class="math inline">\(x_i\)</span>，有<br />
<span class="math display">\[x_i=x_0+\frac{b}{gcd(a,b)}
\times{t}x\]</span></p>
<p>下面以<a href="https://www.luogu.com.cn/problem/P1516">洛谷-P1516
青蛙的约会</a>为例来说明其应用</p>
<p>第一步首先建立对应模型即找出要求解的方程组：</p>
<p>青蛙<span class="math inline">\(A\)</span>走了<span
class="math inline">\(k\)</span>步来到了<span
class="math inline">\((x+km)\mod L\)</span>，青蛙<span
class="math inline">\(B\)</span>走了<span
class="math inline">\(k\)</span>步来到了<span
class="math inline">\((y+kn)\mod L\)</span>，所以这里就是解一个关于<span
class="math inline">\(k\)</span>的不定方程的最小正数解：<span
class="math inline">\(x+km\equiv y+kn(\mod
L)\)</span>。移项后写成等号的形式得到<span
class="math inline">\(k(m-n)+zL = y-x\)</span>。这样一个关于<span
class="math inline">\(k\)</span>和<span
class="math inline">\(z\)</span>的二元一次不定方程可以用扩展欧几里得算法来解决。</p>
<p>第二步求解对应的不定方程：</p>
<p>首先，求出方程组<span class="math inline">\(k(m-n)+zL = \gcd(m-n,
L)\)</span>的一组特解；</p>
<p>然后，根据通解的格式求出方程组的最小解；</p>
<p>因为<br />
<span class="math display">\[k_j=k_{min}+\frac{L}{\gcd(m-n,L)}
\times{t}\]</span></p>
<p>那么对于这个方程，对于<span class="math inline">\(t \in
Z\)</span>而言，想要通过一个特解推出最小解，可以如此做：<br />
<span class="math display">\[k_{min}=k_j \mod\frac{L}{\gcd(m-n,L)}
\]</span></p>
<p>最后，因为这个<span
class="math inline">\(k\)</span>是建立在exgcd得出的方程上的，所以将结果<span
class="math inline">\(\times
\frac{y-x}{\gcd(m-n,L)}\)</span>就是最终答案</p>
<p>还有个细节要注意：gcd只对非负整数有意义，当<span
class="math inline">\(m-n&lt;0\)</span>时需要特别处理下</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
ll x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> L<span class="token punctuation">;</span>
ll <span class="token function">exgcd</span><span class="token punctuation">(</span>ll a<span class="token punctuation">,</span> ll b<span class="token punctuation">,</span> ll <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> ll <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> a<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	ll d <span class="token operator">=</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token operator">%</span>b<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	y <span class="token operator">-=</span> <span class="token punctuation">(</span>a<span class="token operator">/</span>b<span class="token punctuation">)</span><span class="token operator">*</span>x<span class="token punctuation">;</span>
	<span class="token keyword">return</span> d<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld%lld%lld%lld%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token comment">//求解k*(m-n)+zL=gcd(m-n, L)</span>
	ll f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
	<span class="token comment">//注意gcd只对非负整数有意义</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">-</span>n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//处理m-n为负数情况</span>
	ll d <span class="token operator">=</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>m<span class="token operator">-</span>n<span class="token punctuation">,</span> L<span class="token punctuation">,</span> k<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token operator">%</span>d<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> 
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		k <span class="token operator">=</span> f<span class="token operator">*</span>k<span class="token operator">*</span><span class="token punctuation">(</span>y<span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token operator">/</span>d<span class="token punctuation">;</span> <span class="token comment">//求解k*(m-n)+zL=y-x</span>
		k <span class="token operator">=</span> <span class="token punctuation">(</span>k<span class="token operator">%</span><span class="token punctuation">(</span>L<span class="token operator">/</span>d<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>L<span class="token operator">/</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>L<span class="token operator">/</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//求出最小的正数L </span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="算数基本定理唯一分解定理">算数基本定理（唯一分解定理）</h2>
<blockquote>
<p>一个数可以分解成若干个质数的乘积，如：<span
class="math inline">\(120=2^3\times 3 \times
5\)</span>。这样可以从一个新的角度来看待整数：正整数都是由质数为基底"构筑"的。</p>
</blockquote>
<p>设正整数 <span class="math inline">\(a\)</span>，那么必有表示：<br />
<span class="math display">\[  
a=p_1p_2\cdots p_s  
\]</span><br />
其中 <span class="math inline">\(p_j(1\le j\le s)\)</span>
是素数。并且在不计次序的意义下，该表示唯一。</p>
<p>将上述表示中，相同的素数合并，可得：<br />
<span class="math display">\[  
a={p_1}^{\alpha_1}{p_2}^{\alpha_2}\cdots{p_s}^{\alpha_s},p_1&lt;p_2&lt;\cdots&lt;p_s  
\]</span><br />
称为正整数 <span class="math inline">\(a\)</span>
的标准素因数分解式。</p>
<p>（以下内容不影响素数的学习，感兴趣可以进行选读）<br />
算数基本定理是处理整除性和数论函数的有力工具。下面给出其最常用的推论：</p>
<p><strong>推论1</strong><br />
<span class="math inline">\(d\)</span>是<span
class="math inline">\(a\)</span>的约数的充要条件是<span
class="math inline">\(d\)</span>中每个质数的幂次都不超过<span
class="math inline">\(a\)</span>的</p>
<p>例如<span class="math inline">\(12=2^2\times 3, 72=2^3\times
3^2\)</span>，看到12的质因子上的每个幂次都比72的小，便可以推出<span
class="math inline">\(12\mid 72\)</span></p>
<p><strong>推论2</strong><br />
若<span
class="math inline">\(a={p_1}^{\alpha_1}{p_2}^{\alpha_2}\cdots{p_s}^{\alpha_s},b={p_1}^{\beta_1}{p_2}^{\beta_2}\cdots{p_s}^{\beta_s}\)</span>（允许<span
class="math inline">\(\alpha_i\)</span>或者<span
class="math inline">\(\beta_i\)</span>为0），那么<br />
<span class="math display">\[  
\begin{align}  
(a, b)={p_1}^{\delta_1}{p_2}^{\delta_2}\cdots{p_s}^{\delta_s}  
&amp; \qquad \text{其中}\delta_i=min(\alpha_i, \beta_i)  
\tag 1\\  
[a,b]={p_1}^{\gamma_1}{p_2}^{\gamma_2}\cdots{p_s}^{\gamma_s}  
&amp; \qquad \text{其中}\beta_i=max(\alpha_i, \beta_i)  
\tag 2\\  
\end{align}  
\]</span><br />
比如<span class="math inline">\(10 = 2^1\times 5^1, 16 =
2^4\)</span>，那么<br />
<span class="math display">\[(10, 16)=2^{min(1,4)}\times
5^{min(1,0)}=2^1\times 5^0=2\]</span><br />
<span class="math display">\[[10, 16]=2^{max(1,4)}\times
5^{max(1,0)}=2^4\times 5^1=80\]</span></p>
<p><strong>下面推论3和推论4都可以由乘法原理得出</strong></p>
<p><strong>推论3</strong><br />
用除数函数<span class="math inline">\(\tau(a)\)</span>表示<span
class="math inline">\(a\)</span>的所有正约数的个数，则<br />
<span class="math display">\[  
\begin{align}  
\tau(a)  
&amp;=(\alpha_1+1)(\alpha_2+1)\cdots (\alpha_s+1)\\  
&amp;=\tau(p_1^{\alpha_1})\cdots \tau(p_1^{\alpha_s})  
\end{align}  
\]</span><br />
比如<span class="math inline">\(a=2^7\times
3^8\times5^9\)</span>，则其约数个数为<br />
<span class="math display">\[(7+1)(8+1)(9+1)=720\]</span></p>
<p><strong>推论4</strong><br />
用除数和函数<span class="math inline">\(\sigma(a)\)</span>表示<span
class="math inline">\(a\)</span>的所有正约数的和，则<br />
<span class="math display">\[  
\begin{align}  
\sigma(a)  
&amp;=(p_1^0+p_1^1+\cdots+p_1^{\alpha_1})\times  
(p_2^0+p_2^1+\cdots+p_2^{\alpha_2})\times  
\cdots \times (p_s^0+p_s^1+\cdots+p_s^{\alpha_s})\\  
&amp;=\sigma(p_1^{\alpha_1})\dots \sigma(p_1^{\alpha_s})\\  
&amp;=\frac{p_1^{\alpha_1+1}-1}{p_1-1}\cdots
\frac{p_1^{\alpha_s+1}-1}{p_1-1}\\  
\end{align}  
\]</span><br />
比如<br />
<span class="math display">\[  
\begin{align}  
\sigma(60)  
&amp;=(2^0+2^1+2^2)(3^0+3^1)(5^0+5^1)\\  
&amp;=1+2+4+3+6+12+5+10+20+15+30+60  
\end{align}  
\]</span><br />
上述可以这么操作的原因，是因为其中某个约数必须是各个质因数幂次方的乘积，而每个质因数<span
class="math inline">\(p_i\)</span>有<span
class="math inline">\(\alpha_i+1\)</span>种选择。对于求正约数个数而言，每次选取的代价就是1，但是这里是求和选取的代价就是<span
class="math inline">\(p_i^k\quad (0\leq k \leq \alpha_i)\)</span></p>
<h2 id="素数与合数">素数与合数</h2>
<p>若一个正整数无法被除了1和它自身之外的任何自然数整除，则称该数为质数（或素数）,否则称该正整数为合数。</p>
<h3 id="质数的判定">质数的判定</h3>
<p><span class="math inline">\(n\)</span>的约数都不超过<span
class="math inline">\(n\)</span>，所以只要检查<span
class="math inline">\(2 \sim n-1\)</span>的所有整数是否整除<span
class="math inline">\(n\)</span>就能判定<span
class="math inline">\(n\)</span>是不是质数。</p>
<p>但是真的有必要每个数都去判断吗？</p>
<p>很容易发现这样一个事实：如果 <span class="math inline">\(x\)</span>
是 <span class="math inline">\(n\)</span> 的约数，那么 <span
class="math inline">\(\frac{n}{x}\)</span> 也是 <span
class="math inline">\(n\)</span> 的约数。</p>
<p>这个结论告诉我们，对于每一对 <span class="math inline">\((x,
\frac{n}{x}
)\)</span>，只需要检验其中的一个就好了。为了方便起见，我们之考察每一对里面小的那个数。不难发现，所有这些较小数就是
<span class="math inline">\([1, \sqrt{n}]\)</span> 这个区间里的数。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">is_prime</span><span class="token punctuation">(</span>ll n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">*</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="质数的筛选">质数的筛选</h3>
<p>给定一个整数<span class="math inline">\(N\)</span>，求出<span
class="math inline">\(1 \sim
N\)</span>之间的所有质数，称为质数的筛选问题。<strong>简单来说把合数都去掉，剩下的就是质数了。</strong></p>
<h4 id="埃氏筛eratosthenes">埃氏筛(Eratosthenes)</h4>
<p>考虑这样一件事情：<strong>对于任意一个大于 <span
class="math inline">\(1\)</span> 的正整数 <span
class="math inline">\(n\)</span>，那么它的 <span
class="math inline">\(x\)</span> 倍就是合数（<span
class="math inline">\(x&gt;1\)</span>）</strong>。利用这个结论，我们可以避免很多次不必要的检测。</p>
<p>如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。</p>
<blockquote>
<p><strong>教学参考</strong><br />
有的学生在课上直接把所有数从小到大的倍数全部筛了一遍，不过也很聪明的筛到<span
class="math inline">\(n/2\)</span>，因为这样再筛<span
class="math inline">\(*2\)</span>就超过<span
class="math inline">\(n\)</span>了。这时就需要和他们解释一个数可以分解成若干个质数的乘积(算数基本定理)，如：<span
class="math inline">\(120=2^3\times 3 \times
5\)</span>，那么一个合数只要其被质数筛了就已经足够了，同时在这个基础上也解释了为什么下一个找的一定是一个素数</p>
</blockquote>
<p><strong>埃氏筛核心：从2开始删去素数本身倍数，向后找到的第一个数字一定是素数。</strong></p>
<p>证明：简略一说，设已找到第n个素数，删去此数自身倍数后找到剩下的第一个数字L，知L之前有且仅有n个素数，且都无法整除L，即L无法被小于自身的所有素数整除，推出L是素数（L就是第n+1个素数）。照此由第一个素数2往后递推即可</p>
<p>首先，将2到<span
class="math inline">\(n\)</span>范围内的所有整数写下来。其中最小的数字2是质数,将表中所有2的倍数都划去。表中剩余的最小数字是3，它不能被更小的数整除，所以是质数。再将表中所有3的倍数都划去。
依此类推，如果表中剩余的最小数字是<span
class="math inline">\(x\)</span>时，<span
class="math inline">\(x\)</span>就是质数。然后将表中所有<span
class="math inline">\(x\)</span>的倍数都划去。像这样反复操作，就能依次枚举<span
class="math inline">\(n\)</span>以内的质数。具体过程如下如图所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/埃氏筛.png" /></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> cnt<span class="token punctuation">,</span> prime<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//存储素数 </span>
<span class="token keyword">bool</span> is_prime<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//值为true表示为素数</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> is_prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
is_prime<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> is_prime<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>is_prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		prime<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token comment">//因为从 2 到 i - 1 的倍数我们之前筛过了</span>
		<span class="token comment">//所有不需要从2*i开始，这里而是直接从i的倍数开始，提高了运行速度</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">*</span>i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span> 
			is_prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>    
<span class="token punctuation">&#125;</span></code></pre>
<h5 id="优化筛至平方根">优化—筛至平方根</h5>
<p>在<a href="###质数的判定">质数的判定</a>中已经提到：<strong><span
class="math inline">\(n\)</span>以内每个合数的最小质因数一定不超过<span
class="math inline">\(\sqrt{n}\)</span>，因此我们只需要筛到 <span
class="math inline">\(\sqrt{n}\)</span>就能把所有的合数给筛出去</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> is_prime<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> is_prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
is_prime<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> is_prime<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>is_prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span> 
			is_prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h5 id="区间的筛法">区间的筛法</h5>
<p>若给定区间<span
class="math inline">\([L,R]\)</span>，那么区间内的质数有该如何求呢？</p>
<p>一般情况下，<span class="math inline">\(L\)</span>和<span
class="math inline">\(R\)</span> 的范围往往比较大，不过根据前面的<a
href="#####优化—筛至平方根">推论</a>，我们只需利用不超过 <span
class="math inline">\(\sqrt{R}\)</span>的质数就能将所有<span
class="math inline">\([2,R]\)</span>所有的合数筛出去。</p>
<p>因此，第一步先得到<span
class="math inline">\(\sqrt{R}\)</span>内质数；第二步，利用<span
class="math inline">\(\sqrt{R}\)</span>内质数筛去区间<span
class="math inline">\([L,R]\)</span>间的合数即可，同时为了节省空间可以将<span
class="math inline">\([L,R]\)</span>的信息映射到<span
class="math inline">\([0,R-L]\)</span></p>
<p>下面以<a href="https://www.luogu.com.cn/problem/P1835">P1835
素数密度</a>为例来说明其具体实现：</p>
<p>需要注意的是1不是质数</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e6</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
ll L<span class="token punctuation">,</span> R<span class="token punctuation">;</span>
<span class="token keyword">int</span> cnt<span class="token punctuation">,</span> pri<span class="token punctuation">[</span><span class="token number">100100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> vis<span class="token punctuation">[</span><span class="token number">100100</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//用于判断是否是合数和质数 </span>
<span class="token keyword">int</span> <span class="token function">sieve</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">*</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">*</span>i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span>
				vis<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> pri<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token operator">&amp;</span>R<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//特判 1不是素数 </span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> L <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token function">sieve</span><span class="token punctuation">(</span><span class="token number">50000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> cnt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token comment">//得出的是(>=L &amp;&amp; %pri[i]==0)离l最近的数</span>
		ll st <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">2ll</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>L<span class="token operator">+</span>pri<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span>pri<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span>pri<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token comment">//筛去 pri[i]的倍数 </span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>ll j <span class="token operator">=</span> st<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> R<span class="token punctuation">;</span> j <span class="token operator">+=</span> pri<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			res<span class="token punctuation">[</span>j<span class="token operator">-</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>ll i <span class="token operator">=</span> L<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> R<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span> tot<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> tot<span class="token punctuation">)</span><span class="token punctuation">;</span> 		
<span class="token punctuation">&#125;</span></code></pre>
<h4 id="线性筛待解决">线性筛（待解决）</h4>
<p>埃氏筛法中，它会将一个合数重复多次标记。例如2和3都是质数，它们会将6这个合数标记两次，有没有什么办法省掉无意义的步骤呢？答案是肯定的。</p>
<hr />
<p>参考自：<br />
<a href="https://oi-wiki.org/math/number-theory/gcd/">OI-Wiki
gcd</a><br />
<a
href="https://zhuanlan.zhihu.com/p/124068032">关于从埃氏筛到线性筛你不会想知道的那些事（证明，慎入）</a><br />
<a
href="https://www.luogu.com.cn/blog/pks-LOVING/solution-p1516">不定方程的解法
&amp; 题解 P1516 【青蛙的约会】</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>数论—模运算的世界</title>
    <url>/posts/26315.html</url>
    <content><![CDATA[<h2 id="为什么需要求余数">为什么需要求余数</h2>
<p>在程序设计竞赛中，如果计算结果超出了64位整数的范围，则可能会要求输出结果对合适的数取模后的余数。这样可以消除在高精度计算方面，语言的差异所带来的不利因素。例如，Java中有
支持高精度计算的类Biglnteger，而C++和C则不得不靠自己实现。另一方面，高精度乘法不同实
现的复杂度也不一样，因此，对算法本身的评价变得更为困难。正因为此类理由，程序设计竞赛
中经常出现余数的计算</p>
<h2 id="模运算的基本概念与性质">模运算的基本概念与性质</h2>
<h3 id="模的概念与性质">模的概念与性质</h3>
<p>对于整数<span class="math inline">\(a,b\)</span>，满足<span
class="math inline">\(b&gt;0\)</span>，则存在唯一的整数<span
class="math inline">\(q,r\)</span>，满足<span
class="math inline">\(a=bq+r\)</span>，其中<span
class="math inline">\(0\leq r &lt; b\)</span>。其中称<span
class="math inline">\(q\)</span>为商，<span
class="math inline">\(r\)</span>为余数。余数用<span
class="math inline">\(a\ mod\ b\)</span>或者<span
class="math inline">\(a\%b\)</span>表示。</p>
<ol type="1">
<li><span class="math inline">\((a+b)\mod M=(a\mod M+b\mod M)\mod
M\)</span></li>
<li><span class="math inline">\((a-b)\mod M=(a\mod M-b\mod M)\mod
M\)</span></li>
<li><span class="math inline">\((a\times b)\mod M=(a\mod M\times b\mod
M)\mod M\)</span></li>
</ol>
<p>（温馨提示：先学习后面的<a
href="##乘法逆元">乘法逆元</a>再回来看下面的内容）</p>
<p>那么下面来看看，能不能进行“模除法”？例如<span
class="math inline">\(5/2\equiv ?\pmod 7\)</span>。</p>
<p>我们这样来看，在实数的世界里，如果 <span
class="math inline">\(x=5/2\)</span> ，那么就有 <span
class="math inline">\(2\times x=5\)</span> 。</p>
<p>类比地，在模7的运算的世界里，如果 <span
class="math inline">\(5/2\equiv y\pmod 7\)</span>，那么也应该有 <span
class="math inline">\(2\times y\equiv 5\pmod
7\)</span>，可以得到这个值为6。由此可以见是可以进行“模除法”的，那么该如何求模意义下的除法呢？</p>
<p><strong>对于模意义下的除法我们可以利用乘法逆元将其转化为乘法</strong>。先将<span
class="math inline">\(b\)</span>在模<span
class="math inline">\(M\)</span>的意义下的逆元求出来，再与<span
class="math inline">\(a\)</span>相乘，再模<span
class="math inline">\(M\)</span>即可</p>
<ol start="4" type="1">
<li><span class="math inline">\((\frac{a}{b})\mod M = (a\mod M\times
b^{-1}\mod M)\mod M\)</span></li>
</ol>
<h3 id="同余的概念与性质">同余的概念与性质</h3>
<p>若两数<span class="math inline">\(x,y\)</span>除以<span
class="math inline">\(M\)</span>的余数相等，则称<span
class="math inline">\(x,y\)</span>模<span
class="math inline">\(M\)</span>同余，记做<span
class="math inline">\(x\equiv y\pmod M\)</span></p>
<p>以下是几个最基础的性质：</p>
<ol type="1">
<li>自反性：<span class="math inline">\(x\equiv x\pmod M\)</span></li>
<li>对称性：若<span class="math inline">\(x\equiv y\pmod
M\)</span>，则<span class="math inline">\(y\equiv x\pmod M\)</span></li>
<li>传递性：若<span class="math inline">\(x\equiv y\pmod M, y\equiv
z\pmod M\)</span>，则<span class="math inline">\(x\equiv z\pmod
M\)</span></li>
</ol>
<p>根据上述取模运算的计算方法，同余还有以下性质：<br />
4. 同加性：若<span class="math inline">\(x\equiv y\pmod
M\)</span>，则<span class="math inline">\(x+z\equiv y+z\pmod
M\)</span><br />
5. 同乘性：若<span class="math inline">\(x\equiv y\pmod
M\)</span>，则<span class="math inline">\(x\times z\equiv y\times z\pmod
M\)</span><br />
6. 同幂性：若<span class="math inline">\(x\equiv y\pmod
M\)</span>，则<span class="math inline">\(x^n\equiv y^n\pmod
M\)</span><br />
7. <span class="math inline">\(x\times y\pmod M \Leftrightarrow M |
(x-y)\)</span></p>
<h2 id="乘法逆元">乘法逆元</h2>
<p>在实数意义下，对于任意<span class="math inline">\(a \neq
0\)</span>，都有<span class="math inline">\(a \times
\frac{1}{a}=1\)</span>，<span
class="math inline">\(\frac{1}{a}\)</span>称作是<span
class="math inline">\(a\)</span>的倒数。所以在模意义下，也希望<span
class="math inline">\(\frac{1}{a}\)</span>满足这样的性质：<span
class="math inline">\(a \times \frac{1}{a}\equiv 1(\mod\
p)\)</span>。也就是说，尝试找到一个整数<span
class="math inline">\(x\)</span>，满足<span class="math inline">\(a
\times x\equiv 1(\mod\ p)\)</span></p>
<p>若<span class="math inline">\(a \times x\equiv 1(\mod\
p)\)</span>，则称<span class="math inline">\(x\)</span>为<span
class="math inline">\(a\)</span>在模<span
class="math inline">\(p\)</span>意义下的乘法逆元，记为<span
class="math inline">\(a^{-1}(\mod\ p)\)</span></p>
<p>接下来介绍两种方法来求出<span
class="math inline">\(a\)</span>在模<span
class="math inline">\(p\)</span>意义下的逆元</p>
<p><strong>方法1：扩展欧几里得算法</strong><br />
从<span class="math inline">\(a \times x\equiv 1(\mod\
p)\)</span>这个式子入手发现，它和<span class="math inline">\(\exists y,\
ax+py=1\)</span>等价，可以使用扩展欧几里得算法解出这个关于<span
class="math inline">\(a,p\)</span>的不定方程。并且由裴蜀定理可以发现存在<span
class="math inline">\(a\)</span>在模<span
class="math inline">\(p\)</span>意义下的逆元当且仅当<span
class="math inline">\(gcd(a, p) = 1\)</span>，即<span
class="math inline">\(a\)</span>和<span
class="math inline">\(p\)</span>互质（<span class="math inline">\(a\perp
p\)</span>）。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">inv</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
	<span class="token function">exgcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p><strong><code>提示</code></strong><br />
<strong>逆元有时求出来可能是负数</strong>。例如若<span
class="math inline">\(a=2,p=3\)</span>，求<span
class="math inline">\(a\)</span>的逆元。<br />
即求<span class="math inline">\(x\)</span>使得<span
class="math inline">\(2x\equiv 1\pmod 3\)</span>，等同于<span
class="math inline">\(2x+3y=1\)</span>，其中一组解为<span
class="math inline">\((-1,1)\)</span>，此时-1就是<span
class="math inline">\(a\)</span>的逆元</p>
<p><strong>方法2：费马小定理</strong><br />
费马小定理：若<span class="math inline">\(p\)</span>是质数，且<span
class="math inline">\(a\)</span>不是<span
class="math inline">\(p\)</span>的倍数，则<span
class="math inline">\(a^{p-1}\equiv 1(\mod\ p)\)</span></p>
<p>那么假如<span
class="math inline">\(p\)</span>是质数，就可以知道如果<span
class="math inline">\(a\)</span>不是<span
class="math inline">\(p\)</span>的倍数，就有<span
class="math inline">\(a \times a^{p-2}=a^{p-1}\equiv 1(\mod\
p)\)</span>。根据乘法逆元的定义，就知道<span
class="math inline">\(a\)</span>在模<span
class="math inline">\(p\)</span>意义下的逆元是<span
class="math inline">\(a^{p-2}\)</span>，可以用快速幂求出。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">inv</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">qpow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="线性求逆元">线性求逆元</h3>
<p>求出 <span class="math inline">\(1,2,...,n\)</span> 中每个数关于
<span class="math inline">\(p\)</span> 的逆元。</p>
<p>如果对于每个数进行单次求解，以上两种方法就显得慢了，很有可能超时，所以下面来讲一下如何线性（<span
class="math inline">\(O(n)\)</span>）求逆元。</p>
<p><strong>递推：</strong> 假设现在已经知道了<span
class="math inline">\(1 \sim i-1\)</span>的逆元，现在想要求<span
class="math inline">\(i\)</span>的逆元</p>
<p>递推的初始情况：当<span class="math inline">\(i=1\)</span>时，<span
class="math inline">\(i^{-1} \equiv 1(\mod\ p)\)</span>。接下来考虑<span
class="math inline">\(2\leq i &lt; p\)</span> 的情况</p>
<p>我们令 <span class="math inline">\(k = \lfloor \frac{p}{i}
\rfloor\)</span>，<span class="math inline">\(j = p \bmod i\)</span>，有
<span class="math inline">\(p = ki + j\)</span>。再放到 <span
class="math inline">\(\mod p\)</span> 意义下就会得到：<span
class="math inline">\(ki+j \equiv 0 \pmod p\)</span>；</p>
<p>两边同时乘 <span class="math inline">\(i^{-1} \times
j^{-1}\)</span>（<span class="math inline">\(j&lt;i\Rightarrow
j^{-1}\)</span>存在）：<br />
<span class="math inline">\(kj^{-1}+i^{-1} \equiv 0 \pmod
p\)</span><br />
<span class="math inline">\(i^{-1} \equiv -kj^{-1} \pmod
p\)</span><br />
再带入 <span class="math inline">\(j = p \bmod i\)</span>，有 <span
class="math inline">\(p = ki + j\)</span>，有：<br />
<span class="math inline">\(i^{-1} \equiv -\lfloor\frac{p}{i}\rfloor (p
\bmod i)^{-1} \pmod p\)</span></p>
<p>我们注意到 <span class="math inline">\(p \bmod i &lt;
i\)</span>，而在迭代中我们完全可以假设我们已经知道了所有的模 <span
class="math inline">\(p\)</span> 下的逆元 <span
class="math inline">\(j^{-1}, j &lt; i\)</span>。</p>
<p>故我们就可以推出逆元，利用递推的形式实现：</p>
<p><span class="math display">\[  
i^{-1} \equiv \begin{cases}  
    1,                                           &amp; \text{if } i = 1,
\\  
    -\lfloor\frac{p}{i}\rfloor (p \bmod i)^{-1}, &amp;
\text{otherwises}.  
\end{cases} \pmod p  
\]</span></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">inv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token comment">//防止出现负数</span>
	inv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-</span>inv<span class="token punctuation">[</span>p<span class="token operator">%</span>i<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">;</span></code></pre>
<h3 id="线性求任意-n-个数的逆元">线性求任意 n 个数的逆元</h3>
<p>上面的方法只能求 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的逆元，如果需要求任意给定 <span
class="math inline">\(n\)</span> 个数（<span class="math inline">\(1 \le
a_i &lt; p\)</span>）的逆元，就需要下面的方法：</p>
<p>首先计算 <span class="math inline">\(n\)</span> 个数的前缀积，记为
<span
class="math inline">\(s_i\)</span>，然后使用快速幂或扩展欧几里得法计算
<span class="math inline">\(s_n\)</span> 的逆元，记为 <span
class="math inline">\(sv_n\)</span>。</p>
<p>因为 <span class="math inline">\(sv_n\)</span> 是 <span
class="math inline">\(n\)</span> 个数的积的逆元，所以当我们把它乘上
<span class="math inline">\(a_n\)</span> 时，就会和 <span
class="math inline">\(a_n\)</span> 的逆元抵消，于是就得到了 <span
class="math inline">\(a_1\)</span> 到 <span
class="math inline">\(a_{n-1}\)</span> 的积逆元，记为 <span
class="math inline">\(sv_{n-1}\)</span>。</p>
<p>同理我们可以依次计算出所有的 <span
class="math inline">\(sv_i\)</span>，于是 <span
class="math inline">\(a_i^{-1}\)</span> 就可以用 <span
class="math inline">\(s_{i-1} \times sv_i\)</span> 求得。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">%</span>p<span class="token punctuation">;</span>
sv<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">qpow</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> sv<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">%</span>p<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> inv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">%</span>p<span class="token punctuation">;</span></code></pre>
<h2 id="同余方程与中国剩余定理">同余方程与中国剩余定理</h2>
<p>形如  <span class="math inline">\(ax\equiv c(\mod\
b)\)</span>的方程被称为 <strong>线性同余方程</strong></p>
<p>而在中国古代就有这类问题的踪影：</p>
<blockquote>
<p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p>
</blockquote>
<p>即求满足以下条件的整数：除以3余2，除以5余3，除以7余2。可以转写成下面这样一个方程组：<br />
<span class="math display">\[  
\begin{cases}  
x &amp;\equiv 2 \pmod {3} \\  
x &amp;\equiv 3 \pmod {5} \\  
x &amp;\equiv 2 \pmod {7} \\  
\end{cases}  
\]</span></p>
<p>该问题最早见于《孙子算经》中，并有该问题的具体解法。上面具体问题的解答口诀由明朝数学家程大位在《算法统宗》中给出：</p>
<blockquote>
<p>三人同行七十希，五树梅花廿(niàn)一支，七子团圆正半月，除百零五便得知。</p>
</blockquote>
<h3 id="求解同余方程组中国剩余定理">求解同余方程组—中国剩余定理</h3>
<p>一般来说，中国剩余定理(Chinese Remainder Theorem,
CRT)可以用来求解下面这样一类方程组：<br />
<span class="math display">\[  
\begin{cases}  
x &amp;\equiv a_1 \pmod {m_1} \\  
x &amp;\equiv a_2 \pmod {m_2} \\  
  &amp;\vdots \\  
x &amp;\equiv a_n \pmod {m_n} \\  
\end{cases}  
\]</span></p>
<p>其中，<span class="math inline">\(m_1,m_2, \cdots,
m_n\)</span>两两互质，则对于任意的整数<span
class="math inline">\(a_1,a_2, \cdots,
a_n\)</span>，上面这个方程组有解。中国剩余定理给出了 解的构造方式：</p>
<ol type="1">
<li>计算所有模数的积<span class="math inline">\(M=m_1\times m_2\times
\cdots\times m_n=\prod_{i=1}^nm_i\)</span>。</li>
<li>对于第i个方程计算：
<ol type="i">
<li><span class="math inline">\(M_i =\frac{M}{m_i}\)</span><br />
</li>
<li>计算 <span class="math inline">\(M_i\)</span> 在模 <span
class="math inline">\(m_i\)</span> 意义下的逆元 <span
class="math inline">\(M_i^{-1}\)</span>（易知<span
class="math inline">\(M_i\)</span> 和<span
class="math inline">\(m_i\)</span>是互质的，所以逆元一定存在）<br />
</li>
<li>计算<span
class="math inline">\(b_i=M_iM_i^{-1}\)</span>（<strong>不要对 <span
class="math inline">\(m_i\)</span> 取模</strong>）</li>
</ol></li>
<li>方程组的唯一解为：<span class="math inline">\(x=\sum_{i=1}^n a_ib_i
\pmod M\)</span>。</li>
</ol>
<p>可以先来验证一下上面问题的解：</p>
<ol type="1">
<li><span class="math inline">\(M=3\times 5\times 7=105\)</span>；</li>
<li>三人同行 <strong>七十</strong> 希：<span
class="math inline">\(m_1=3, M_1=M/m_1=35, M_1^{-1}\equiv 2\pmod
3\)</span>，故 <span class="math inline">\(b_1=35\times
2=70\)</span>；</li>
<li>五树梅花 <strong>廿一</strong> 支：<span
class="math inline">\(m_2=5, M_2=M/m_2=21, M_2^{-1}\equiv 1\pmod
5\)</span>，故 <span class="math inline">\(b_2=21\times
1=21\)</span>；</li>
<li>七子团圆正 <strong>半月</strong>：<span class="math inline">\(m_3=7,
M_3=M/m_3=15, M_3^{-1}\equiv 1\pmod 7\)</span>，故 <span
class="math inline">\(b_3=15\times 1=15\)</span>；</li>
<li>所以方程组的唯一解为 <span class="math inline">\(x\equiv 2\times
70+3\times 21+2\times 15\equiv 233\equiv 23 \pmod {105}\)</span>。（除
<strong>百零五</strong> 便得知）</li>
</ol>
<p>下面我们来证明这个方法的正确性：</p>
<p>由于</p>
<ol type="1">
<li>显然<span class="math inline">\(b_i=M_iM_i^{-1} \equiv 1\pmod
{m_i}\)</span></li>
<li>对于<span class="math inline">\(j\neq i\)</span>，<span
class="math inline">\(M_j\)</span>为<span
class="math inline">\(m_i\)</span>的倍数，即<span
class="math inline">\(M_j\equiv 0\pmod {m_i}\)</span>。故<span
class="math inline">\(b_j=M_jM_j^{-1} \equiv 0\pmod {m_i}\)</span></li>
</ol>
<p>可以得到<br />
<span class="math display">\[  
\begin{aligned}  
x&amp;\equiv \sum_{j=1}^n a_jb_j                      &amp;\pmod {m_i}
\\  
&amp;\equiv a_ib_i+\sum_{j\neq i}^n
a_jb_j                                      &amp;\pmod {m_i} \\  
&amp;\equiv a_i                                      &amp;\pmod {m_i}  
\end{aligned}  
\]</span></p>
<p>具体代码实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll <span class="token function">crt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> ll<span class="token operator">*</span> a<span class="token punctuation">,</span> ll<span class="token operator">*</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  ll M <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">//M=r1*r2*...*rn</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> M <span class="token operator">=</span> M <span class="token operator">*</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">//mi=M/ri</span>
    ll m <span class="token operator">=</span> M<span class="token operator">/</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
    <span class="token function">exgcd</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// m * t mod r[i] = 1</span>
    x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>m<span class="token operator">*</span>t<span class="token operator">%</span>M<span class="token punctuation">)</span><span class="token operator">%</span>M<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>x<span class="token operator">%</span>M<span class="token operator">+</span>M<span class="token punctuation">)</span><span class="token operator">%</span>M<span class="token punctuation">;</span><span class="token comment">//保证x是正数</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>以<a href="https://www.luogu.com.cn/problem/P1495">洛谷-P1495
曹冲养猪</a>为例说明其实际应用：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span> </span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">;</span>
ll r<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
ll <span class="token function">exgcd</span><span class="token punctuation">(</span>ll a<span class="token punctuation">,</span>ll b<span class="token punctuation">,</span> ll <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> ll <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	ll d <span class="token operator">=</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	y <span class="token operator">-=</span> <span class="token punctuation">(</span>a<span class="token operator">/</span>b<span class="token punctuation">)</span><span class="token operator">*</span>x<span class="token punctuation">;</span>
	<span class="token keyword">return</span> d<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
ll <span class="token function">crt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> ll<span class="token operator">*</span> a<span class="token punctuation">,</span> ll<span class="token operator">*</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  ll M <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> M <span class="token operator">=</span> M <span class="token operator">*</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ll m <span class="token operator">=</span> M<span class="token operator">/</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
    <span class="token function">exgcd</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>m<span class="token operator">*</span>t<span class="token operator">%</span>M<span class="token punctuation">)</span><span class="token operator">%</span>M<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>x<span class="token operator">%</span>M<span class="token operator">+</span>M<span class="token punctuation">)</span><span class="token operator">%</span>M<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token function">crt</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<hr />
<p>参考自：<br />
<a href="https://oi-wiki.org/math/number-theory/inverse/">OI-Wiki
乘法逆元</a><br />
<a href="https://oi-wiki.org/math/number-theory/crt/">OI-Wiki
中国剩余定理</a><br />
《深入浅出程序设计竞赛—进阶版》</p>
<p><a
href="https://www.jianshu.com/p/967729f7a218">知识点:各种求逆元的技术</a><br />
<a
href="https://zhuanlan.zhihu.com/p/44523169">5÷2=6？—是的，模7意义下</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>数论—组合数学与计数</title>
    <url>/posts/13303.html</url>
    <content><![CDATA[<h2 id="加法和乘法原理">加法和乘法原理</h2>
<p><strong>加法原理：</strong> 做一件事，有<span
class="math inline">\(n\)</span>类方法，每类方法中分别有<span
class="math inline">\(m_1,m_2,...,
m_n\)</span>种方法，则完成这件事有<span
class="math inline">\(\sum_{i=1}^{n} m_i\)</span>种不同的方案</p>
<p><strong>乘法原理：</strong> 做一件事，有<span
class="math inline">\(n\)</span>个步骤需要依次完成，每一步中分别有<span
class="math inline">\(m_1,m_2,...,
m_n\)</span>种方法，则完成这件事有<span
class="math inline">\(\prod_{i=1}^{n} m_i\)</span>种不同的方案</p>
<h2 id="排列组合">排列组合</h2>
<p><strong>排列数：</strong> 从<span
class="math inline">\(n\)</span>个人里面选出<span
class="math inline">\(m\)</span>个人占成一排，考虑这些人的相对顺序，方案数是<span
class="math inline">\(A_{n}^{m} = n \cdot (n-1) \cdots
(n-m+1)=\frac{n!}{(n-m)!}\)</span></p>
<p>如果在乎排列那么就是 <span
class="math inline">\(A_n^m\)</span>，如果不在乎那么就要除掉重复，那么重复了多少？同样选出的来的
<span class="math inline">\(m\)</span> 个人，他们还要“全排”得 <span
class="math inline">\(A_m^m\)</span>，所以得到组合数的计算公式。</p>
<p><strong>组合数：</strong> 从<span
class="math inline">\(n\)</span>个人里面选出<span
class="math inline">\(m\)</span>个人占成一排，不考虑这些人的相对顺序，方案数是<span
class="math inline">\(C_{n}^{m} = \frac{A_{n}^{m}}{m!}=\frac{n!}{m!
\cdot(n-m)!}\)</span></p>
<h3 id="常见组合计数方法">常见组合计数方法</h3>
<p>如捆绑法、插空法等等</p>
<h3 id="组合数的求解">组合数的求解</h3>
<p>我们知道了有哪些常用的组合计数方法，那么该怎么求解组合数呢？</p>
<p>我们可以直接写出其实现</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll <span class="token function">fac</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	ll f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> f <span class="token operator">*=</span> n<span class="token punctuation">;</span>
	<span class="token keyword">return</span> f<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
ll <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">fac</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token function">fac</span><span class="token punctuation">(</span>n<span class="token operator">-</span>m<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">fac</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>但是有两个问题：</p>
<ol type="1">
<li>求解过程中会调用阶乘函数，但是阶乘函数值很大，计算<span
class="math inline">\(fac(21)=21!=51090942171709440000\)</span> 就已经大于64位整数，就会溢出，答案就不正确了</li>
<li>多次调用并计算阶乘，效率非常低</li>
</ol>
<p>于是我们有另外一种思路，利用递推式：<span
class="math inline">\(C_n^m=C_{n-1}^{m-1}+C_{n-1}^{m}\)</span>，其被称为帕斯卡公式。</p>
<p>上述证明可以由加法原理得到：<br />
要计算<span class="math inline">\(C_{n}^{m}\)</span>也就是“从<span
class="math inline">\(n\)</span>个人里面选<span
class="math inline">\(m\)</span>个”，那么第<span
class="math inline">\(n\)</span>个人要么选，要不不选。所以要完成从<span
class="math inline">\(n\)</span>个人里面选<span
class="math inline">\(m\)</span>个”的任务，可以通过以下两种途径：</p>
<ol type="1">
<li>在前<span class="math inline">\(n-1\)</span>个人里面选<span
class="math inline">\(m-1\)</span>个，然后选走第<span
class="math inline">\(n\)</span>个，方案数是<span
class="math inline">\(C_{n-1}^{m-1}\)</span></li>
<li>在前<span class="math inline">\(n-1\)</span>个人里面选<span
class="math inline">\(m\)</span>个，然后不选走第<span
class="math inline">\(n\)</span>个，方案数是<span
class="math inline">\(C_{n-1}^{m}\)</span></li>
</ol>
<p>知道递推公式，知道初始条件<span
class="math inline">\(C_0^0=C_i^0=1\)</span>，就可以得到所有递推项的值，这种方法相对不容易溢出，但是复杂度为<span
class="math inline">\(O(n^2)\)</span>，具体实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>C<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>C<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>然而，实际上，组合数的增长速度是非常快的， <span
class="math inline">\(C_{100}^{50}\)</span> 已经是30位数， <span
class="math inline">\(C_{300}^{150}\)</span> 则有89位数，比宇宙中的原子数还多。所谓递推不容易溢出，那如果结果本身就溢出了，你又怎么办呢？</p>
<p>所幸算法竞赛中的题目常常会要求将结果对某个质数<span
class="math inline">\(p\)</span>取模，这样一来，溢出的问题就不用太担心了。我们干脆直接回到最原始的方法：
<span class="math inline">\(C_{n}^{m} = \frac{n!}{m!
\cdot(n-m)!}\)</span> 。只不过，现在我们要把除法变成求逆元，也即： <span
class="math inline">\(C_{n}^{m} \equiv n! \cdot (m!)^{-1}\cdot
[(n-m)!]^{-1}\pmod p\)</span>。</p>
<p>模 <span class="math inline">\(p\)</span> 意义下阶乘和逆元都可以<span
class="math inline">\(O(n)\)</span> 预处理出来，然后直接<span
class="math inline">\(O(1)\)</span> 查询即可（实际上不预处理逆元直接 <span
class="math inline">\(O(log⁡\
n)\)</span> 求也绰绰有余）。这基本上是<strong>最常用</strong>的求组合数方法。</p>
<p>当<span class="math inline">\(n&lt;m\)</span>时，规定<span
class="math inline">\(C_n^m=0\)</span></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 需要先预处理出阶乘fac[]和逆元inv[]</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> fac<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fac<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">;</span>
inv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> inv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-</span>inv<span class="token punctuation">[</span>p<span class="token operator">%</span>i<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">;</span>
ll <span class="token function">C</span><span class="token punctuation">(</span>ll n<span class="token punctuation">,</span> ll m<span class="token punctuation">,</span> ll p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span>m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> fact<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">*</span><span class="token function">inv</span><span class="token punctuation">(</span>fact<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token operator">%</span>p <span class="token operator">*</span> <span class="token function">inv</span><span class="token punctuation">(</span>fact<span class="token punctuation">[</span>n<span class="token operator">-</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>一般来说，这个方法够用了。偏偏，有时候， <span
class="math inline">\(p\)</span> 可能比 <span
class="math inline">\(m\)</span> 小……</p>
<p>这下麻烦了。如果 <span class="math inline">\(p\)</span> 比 <span
class="math inline">\(m\)</span> 小，就不能保证 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(m−n\)</span> 的逆元存在了（它们可能是 <span
class="math inline">\(p\)</span> 的倍数）。当然还是可以用帕斯卡公式递推，但 <span
class="math inline">\(O(n^2)\)</span> 还是太不理想。</p>
<p>于是，卢卡斯定理终于要出场了:</p>
<p><span class="math display">\[C_n^m\equiv C_{n\mod p}^{m\mod p}\times
C_{\lfloor n/p\rfloor}^{\lfloor m/p\rfloor}\pmod p\]</span></p>
<p>其中模数<span
class="math inline">\(p\)</span>必须为素数，可以利用这个式子递归求解。观察上述表达式，可知
<span class="math inline">\(n\bmod p\)</span> 和 <span
class="math inline">\(m\bmod p\)</span> 一定是小于 <span
class="math inline">\(p\)</span> 的数，可以直接求解，<span
class="math inline">\(\displaystyle\binom{\left\lfloor n/p
\right\rfloor}{\left\lfloor m/p\right\rfloor}\)</span> 可以继续用 Lucas
定理求解</p>
<p>递归出口是 <span class="math inline">\(m=0\)</span></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll <span class="token function">lucas</span><span class="token punctuation">(</span>ll n<span class="token punctuation">,</span> ll m<span class="token punctuation">,</span> ll p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">%</span>p<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">lucas</span><span class="token punctuation">(</span>n<span class="token operator">/</span>p<span class="token punctuation">,</span> m<span class="token operator">/</span>p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">C</span><span class="token punctuation">(</span>n<span class="token operator">%</span>p<span class="token punctuation">,</span> m<span class="token operator">%</span>p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="二项式定理与杨辉三角">二项式定理与杨辉三角</h3>
<p>二项式<span
class="math inline">\((x+y)^n\)</span>展开，我们可以得到多项式：</p>
<p><span class="math inline">\((x+y)^0 = 1\)</span><br />
<span class="math inline">\((x+y)^1 = x+y\)</span><br />
<span class="math inline">\((x+y)^2 = x^2+2xy+y^2\)</span><br />
<span class="math inline">\((x+y)^3 = x^3+3x^2y+3xy^2+y^3\)</span><br />
<span class="math inline">\((x+y)^4 =
x^4+4x^3y+6x^2y^2+4xy^3+y^4\)</span><br />
<span class="math inline">\((x+y)^5 =
x^5+5x^4y+10x^3y^2+10x^2y^3+5xy^4+y^5\)</span></p>
<p>将其二项式系数表示成三角形中的一种几何排列，就得到了如下图所示的杨辉三角：三角形左边和右边的数字全都是1，而内部的每一个数字都是连接到它的上端的两个数字之和<br />
<img data-src="../images/NOI暑假培训/算法专题/杨辉三角示意图1.gif" /></p>
<p>观察可以发现内部的数字的其他特征：</p>
<p><span class="math inline">\(n\)</span>次幂对应的项数共有 <span
class="math inline">\(n + 1\)</span>
项，而且每一行的数字都是对称的，从外往内看，每一行：</p>
<p>顺数和倒数的第2个数字都是<span
class="math inline">\(n\)</span>，<span
class="math inline">\(C_n^1=C_n^{n-1}=n\)</span><br />
顺数和倒数的第3个数字都是 <span
class="math inline">\(C_n^2=C_n^{n–2}\)</span><br />
<span class="math display">\[\vdots\]</span></p>
<p>所以杨辉三角又可以表示为以下形式：<br />
<img data-src="../images/NOI暑假培训/算法专题/杨辉三角示意图2.gif" /><br />
于是我们发现每行对应的数分别是：<br />
<span class="math display">\[C_n^0, C_n^1,C_n^2,\cdots,
C_n^{n-2},C_n^{n-1},C_n^{n}\]</span></p>
<p><strong>用组合解释</strong>如下：<br />
<span class="math inline">\((x+y)^n\)</span>就是<span
class="math inline">\(n\)</span>个<span
class="math inline">\((x+y)\)</span>相乘，每个<span
class="math inline">\((x+y)\)</span>相乘时有两种选择，选<span
class="math inline">\(x\)</span>或<span
class="math inline">\(y\)</span>。</p>
<p><span class="math inline">\(x^iy^{n-i}\)</span> 出现的次数 =  <span
class="math inline">\(n\)</span>个<span
class="math inline">\((x+y)\)</span> 中取<span
class="math inline">\(i\)</span>个<span
class="math inline">\(x\)</span>的<strong>组合数</strong><span
class="math inline">\(C_n^i\)</span></p>
<p><span class="math inline">\(n\)</span>个<span
class="math inline">\((x+y)\)</span>所有的组合情况，即<span
class="math inline">\((x+y)^n\)</span>的展开式为<br />
<span class="math display">\[\sum_{i=0}^n
C_{n}^{i}x^iy^{n-i}\]</span></p>
<p>比如要计算<span class="math inline">\((ax+by)^k\)</span>中<span
class="math inline">\(x^ny^m\)</span>的系数，即<span
class="math inline">\(x\)</span>取了<span
class="math inline">\(n\)</span>次，<span
class="math inline">\(y\)</span>取了<span
class="math inline">\(m\)</span>次，那么对应的系数就是<span
class="math inline">\(C_k^ma^nb^m\)</span></p>
<h4 id="二项式定理的归纳证明">二项式定理的归纳证明</h4>
对于二项式的展开，我们给出这一结论的归纳证明：<br />
(1) 当<span class="math inline">\(n=1\)</span>时，<span
class="math inline">\((x+y)=x+y\)</span>，结论显然成立。<br />
(2) 不妨假设<span class="math inline">\(n=k\)</span>时结论成立，即<br />
<span class="math display">\[(x+y)^k=\sum_{i=0}^n
C_{k}^{i}x^iy^{k-i}\]</span><br />
而<br />
<span class="math display">\[(x+y)^{k+1}=(x+y)(\sum_{i=0}^n
C_{k}^{i}x^iy^{k-i})\]</span><br />
乘法分配律展开后得到：<br />
$$<br />

<span class="math display">\[\begin{aligned}  
(x+y)^{k+1}  
&amp;= (x+y)(\sum_{i=0}^k C_{k}^{i}x^iy^{k-i}) \\  
&amp;= \sum_{i=0}^k C_{k}^{i}x^{i+1}y^{k-i}

+ \sum_{i=0}^k C_{k}^{i}x^iy^{k+1-i} \\  
&amp;= x^{k+1}+\sum_{i=0}^{k-1}(C_{k}^{i})x^{i+1}y^{k-i}  
+y^{k+1}+\sum_{i=1}^{k}(C_{k}^{i})x^iy^{k+1-i} \\  
&amp;= x^{k+1}+y^{k+1}+\sum_{i=1}^{k}(C_{k}^{i-1}+C_{k}^{i})x^iy^{k+1-i}
\\  
&amp;= x^{k+1}+y^{k+1}+\sum_{i=1}^{k} (C_{k+1}^{i})x^iy^{k+1-i} \\  
&amp;= \sum_{i=0}^{k+1} (C_{k+1}^{i})x^iy^{k+1-i}  
\end{aligned}\]</span>
<p>$$<br />
即结论对<span class="math inline">\(n=k+1\)</span>成立</p>
<ol start="3" type="1">
<li>综上所述，结论对任意<span class="math inline">\(n
\in\mathbb{N}^+\)</span> (正整数集合)成立</li>
</ol>
<p>这里的证明方法被称为<strong>数学归纳法</strong>，只要通过证明最简单形式（<span
class="math inline">\(n\)</span>为较小常数时）的结论以及使用<span
class="math inline">\(n=k\)</span>的结论推出<span
class="math inline">\(n=k+1\)</span>的结论即可证明命题对任意满足条件的<span
class="math inline">\(n\)</span>成立。这是一种重要的数学证明方法，需要掌握。</p>
<p>二项式可以引申出许多有趣的推论：<br />
(1) 取<span class="math inline">\(x=1, y=-1\)</span>有<br />
<span class="math display">\[\sum_{2\mid i} C_n^i = \sum_{2\nmid i}
C_n^i\]</span><br />
(2) 取<span class="math inline">\(x=1,y=1\)</span>有<br />
<span class="math display">\[ \sum_{i=0}^{n} C_n^i =2^n\]</span></p>
<hr />
<p>参考自：<br />
<a href="https://zhuanlan.zhihu.com/p/116698264">算法学习笔记(25):
卢卡斯定理</a><br />
<a
href="https://www.cnblogs.com/RioTian/p/14659917.html">【算法学习笔记】组合数与
Lucas 定理</a><br />
<a
href="https://oi-wiki.org/math/number-theory/lucas/">卢卡斯定理</a><br />
<a
href="http://math001.com/binomial_theorem/">二项式定理与杨辉三角</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>是结束，也是开始</title>
    <url>/posts/44849.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="你再猜猜看哦~." data-whm="我可爱嘛~">
  <script id="hbeData" type="hbeData" data-hmacdigest="2694ba550a46552a462f5c4c63dddffc55a680039f0b2aff709ea7ff85293f73">010f83d7c0da08588458dd64b4144a236259639f45df903cab6bb46cb89d1259ff0a51d4f0eab4432f3bda9f555517403b1b417ff7e6b85de3f652e5558d5ff99d484538a8e50e88fb82476da21126c8bb458a5df418de5b4a104192b99818736518b0640d14f74894c731a35ee2887c1148928641a830e7c8c2601989b6477109b1851f49c38100f48f99a1012e7a739f7bee6610f4523a03d8ec9989cd69f9098ef8762a9171a2381bb8e0d70a758a5d100f9b6b54854f98804d8a80385198acaeb75ec9eb83fb5e6c1f75530780be35168d41b409132ba7561aa86f523fe599d0cb978020478d64137bc3bd774b9aded87036e7ef3f678ab880baf918e94f00425b7052091187351c3c9bc27798a3d2ca1f1008e6582e82683e402f8931f2d1dc09ff061d35bec18c600829f75e9065327b24edb861ec9db1804e0a41c9d7d28b5677b28ec4d9022604a1a70d6d162894147c83d118bb9cd96d57799c3f32ae94baf3b28197b28f47ca72114a606b0f791387a9f1867b6018be18152a0fefd81b4843e0d62bad32ddb03e191778eb760452694d6c4d327dbc434fea70746807a5f175720ef3a6c4dbf6b13a357686b2c0843512252a9b38fa5ee053af3df79eda108cd420f2ca3d498c89a9776926c1f6eb3c2dd68ee8f8d275bfbfbaa4761d4cc1c9db6185737cf441ca92a85db0222d46496d7ed531217721239d19d14c15f87d0d02ced4a8d1c8013c1b383f7a01c6595c31da9f68d1fdfe2b1fe9c0d62a037eb587135f07350fbc793d4060cf718602a9eddf60356fbd8dcd4cbc663d804be69c5caac0ae5cc44281ea3a593b6330623ea9aece99a097424a73d10be155501794a72acaaabe4bf1fec292831e1dd5709e4e03022ed6c31f58aba4f9f4e1c7b12bbac8e50991b744d196252f4600c098c273f0f94d13cd1bb20bf76a17c3540e65a4cfafd959cd4e9a260406c0ab9a0529a4d094b9bf2e7d4a18f7795ab7e3fd21254c024f9c9ac2dec84eee2b94f26b7a7a1a964292bb83e530569333fc6ae08e8e301f2359200061264471f58ea51f820b25a062b54f703946fe6c24e2ec89630e737a332368d9aa284ca866ee58abaedb6433b0ae79e3ae5db534f71d7b01735d4f1d12fbb6fc831a0cda5f1abdb613ca7e4da4c96133287a7876b29fcd914074ab8333cc5b729a59ba1843e5df94c5cc813760c256d0d8af2f123e122090477775f1371da73f59e8bdabc33c755d744515cde18883fd723aaf57483cac1647c3240f00e765d59fff1dbe52e8a36855320fc977ef4dd4e33ef13550344a0d102b258a0b693e44c16d183297698f4b94dbc52d73eafc6c234627f23d8314cab4f3080532cc2eecf3f808c17b6d949d0639955cbac485246103a6bcc37b35909b9dee8c0fbd3702c960e1f5438293bbffcd97165cd71bda47512d414d4ad223b5788f7c46c985751c0bf43d61d03f2bfbf152190569a617e9b32fb3f3b18df62777df48db7fcd7fd4600d5405b9029819b77e0ec3ac520d46cefc5b5ccaa1011290e9388c75362d36d019631dc67cf526ea39b41d98f884f861a0cb6e2d8351a2daedb25fc759dacdc94cad26ffecf9d7ca6df51ea61026e0dbe9e261eef5e42a973ea8508eeeca5074361fd94e11e1620b16aba425eeb4c533d5da49a758184228ff4b8168a68a66b5293be8ae0b23e0e0cca8332585e929f933c1d174b22afdfa114ebe067a1c937dd54185d41a2328c2e75473559bba1addb64518d9f22a8bc454f046eeae3a86bf999f5699184309a93cffa5be24b01554f80cd3569c339c54e5b879aaa7991135e67f3b31bd7cb848f9dc20787766b10e61aece12371c2f758339c63cb02502b0177c17d7300cbf8a504b4b19e4da76c500c3778109d35325949c417634fcb672dbe8f78ab9a79ce324db1dc23e38d8fe8a61fe1162996cc292f54c61210315b986f5ca248bd818be726a76e11d2df291135f95a3daf9c41ce32b95cc45cfc92723135f56e9fcd3056cd12ced4b6ff4a99a726382eb7fd69e68efa33f7f18d0a8638d3ec4bf65e7bb99a47281acfffc6015f863b027d7d704756ccbf456d4dc097b10411574033ccf749ca677f86855c53183c68da32857b8feb21fcbcc44d33d81ad30c391c0e2e809a6061e1287fc28717c2ec837b05ce71e34e5995284a9b7002db65ff76e6ad98bbb19e76f07d92dd4bf1a4c6eff399d9b1c9d7b6f8d18548efb29a603e8a19d66c6411239de7ff9f7a24d31ba371be45d2a5a9c6dc3e7cb9d7c6bb4b1ce0712616a9d1994f30f5881eed2f68aed11024318c098cbd84edbe3dd73f5bdfab5ec9f139694eeb903b10b99bb3d4c464a00ef54839a1205bf73f6af731c746f8e5b3530be3303264490c0cef0bde5600e92a711a5865395d351a0a8fae430c12c8404cd17a21b3a9b27a32350712716668fb981daff93aafff529ca98e7dc045fe3ee6ed945ce27aabff9a498319ee8e4d643d4a6c92bff9a7fc3181e37b929f936559780cb7e1ee915543f0daa65cbf1b4441a939acd1ece93115798e62aa519d6a2c23181e9d0bd033c2052de0a2c7a5e8ce12dcaffbda23483212ed423d0120fd1d6991a1640fa6bd02742b9895a3ad181d33fdf800be0b10d782909525cce79a5183737a8b0025824c8c75c6a8c11126206e429f5bf1bd58fad6a7adae6abd6e70e387d24756336e0383072ea7db4403cfe94262eaeb6652690618f026b535bdb4c0b9bac3729299e1fca8fe5e84f190791d0657d09e2e23bf94f7e5300ee6e7f7f9e08550e271fe6c87e2bb8b39db16c5a425dcc32e80b77ae9cd88dc63364da23e254fcecee439af04389c994372f2da06ce1f1d0418529dee77f7d8416e90a5da59a50737e50b849d2b2844d465db85d8452c6cd09e884e80d90ecd528ba2d3feaebf91dfdacaf14208a3d8a81ea916f5cad56cd284089880a616836bf9adda260bc4eea699d9a53718eb2742cbba2906a8bf65f70292d5291d8437e625308c6b8b324f1aff56d18d6ecca80df608c6271d60149b947c5abeb44f7b4d4163f6d2caf06fc3c64c9b45c56ba53748d09f3dd42c9235b28dc6b7ea2a431f2827c6e5942e4e4f8f49fffd3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码哦~">请输入密码哦~</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>感想与总结</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>blog</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心法</title>
    <url>/posts/19408.html</url>
    <content><![CDATA[<p>贪心法就是遵循某种规律，不断选取当前最优策略的算法设计方法，其适用的前提是：局部最优策略能导致产生全局最优解。一般可以通过反证法和数学归纳法来大致证明其有效性。</p>
<h3 id="hdu-2037-今年暑假不ac区间问题">HDU-2037
今年暑假不AC【区间问题】</h3>
<p><strong>题意</strong><br />
有<span class="math inline">\(n\)</span>项工作，每项工作分别在<span
class="math inline">\(s_i\)</span>时间开始，在<span
class="math inline">\(t_i\)</span>时间结束。对于每项工作，你都可以选择参与与否。如果选择了参与，那么自始至终都必须全程参与。此外，参与工作的时间段不能重叠（即使是开始的瞬间和结束的瞬间的重叠也是不允许的)。你的目标是尽可能多的工作，那么最多能参加多少项工作呢？<br />
<img data-src="../images/NOI暑假培训/算法专题/贪心/HDU-2037示意图.png" /></p>
<p><strong>思路</strong><br />
我们可以想到两种解法：<br />
(1) 每次选取用时最短的工作<br />
(2) 每次选取结束时间最短的工作<br />
上述(2)可以用反证法证明错误:<br />
<img data-src="../images/NOI暑假培训/算法专题/贪心/HDU-2037反例.png" /><br />
而(1)我们认为结束时间越早，以后可选的工作也就越多</p>
<p><strong>代码</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">pii</span> <span class="token expression">pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e5</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> s<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> 
pii work<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>n<span class="token operator">&amp;&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>work<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">,</span> <span class="token operator">&amp;</span>work<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sort</span><span class="token punctuation">(</span>work<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> work<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token comment">//		printf("%d %d\n", work[i].second, work[i].first);</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>work<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token operator">>=</span>last<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				last <span class="token operator">=</span> work<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>
				ans<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<h3 id="poj-3617-best-cow-line字典序最小问题">POJ-3617 Best Cow
Line【字典序最小问题】</h3>
<p><strong>题意</strong><br />
给定长度为N的字符串S,要构造一个长度为N的字符串T。起初，T是一个空串，随后反复进行下列任意操作：</p>
<ul>
<li>从S的头部删除一个字符，加到T的尾部</li>
<li>从S的尾部删除一个字符，加到T的尾部<br />
目标是要构造字典序“尽可能小的字符串T。<br />
<img data-src="../images/NOI暑假培训/算法专题/贪心/POJ-3617%20操作示例图.png" /></li>
</ul>
<p><strong>思路</strong><br />
从字典序的性质上看，无论T的末尾有多大，只要前面部分的较小就可以。所以我们可以试一下如下贪心算法:</p>
<ul>
<li>不断取<span
class="math inline">\(S\)</span>的开头和末尾中较小的一个字符放到<span
class="math inline">\(T\)</span>的末尾。</li>
</ul>
<p>这个算法已经接近正确了，只是针对<span
class="math inline">\(S\)</span>的开头和末尾字符相同的情形还没有定义。<strong>在这种情形下，因为我们希望能够尽早使用更小的字符，所以就要比较下一个字符的大小</strong>。下一
一个字符也有可能相同，因此就有如下算法:</p>
<ul>
<li>按照字典序比较<span class="math inline">\(S\)</span>和将<span
class="math inline">\(S\)</span>反转后的字符串<span
class="math inline">\(S^{&#39;}\)</span>。</li>
<li>如果<span class="math inline">\(S\)</span>较小，就从<span
class="math inline">\(S\)</span>的开头取出一个文字，追加到<span
class="math inline">\(T\)</span>的末尾。</li>
<li>如果<span class="math inline">\(S^{&#39;}\)</span>较小，就从<span
class="math inline">\(S\)</span>的末尾取出一个文字，追加到<span
class="math inline">\(T\)</span>的末尾。<br />
(如果相同则取哪个都可以)</li>
</ul>
<p>根据前面提到的性质，字典序比较类的问题经常能用得上贪心法。</p>
<p><strong>代码</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">2e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token keyword">char</span> s<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> ans<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">" %c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> q <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">&lt;=</span>q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">bool</span> left <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> p<span class="token operator">+</span>i<span class="token operator">&lt;</span>q<span class="token operator">-</span>i<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
			<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>p<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>s<span class="token punctuation">[</span>q<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				left <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>p<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token operator">></span>s<span class="token punctuation">[</span>q<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> 
				<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span> ans<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> ans<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>q<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">80</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i<span class="token punctuation">)</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="poj-3069-sarumans-army">POJ-3069 Saruman's Army</h3>
<p><strong>题意</strong><br />
直线上有<span class="math inline">\(N\)</span>个点。点<span
class="math inline">\(i\)</span>的位置是<span
class="math inline">\(X_i\)</span>。从这<span
class="math inline">\(N\)</span>个点中选择若千个，给它们加上标记。对每一个点，其距离为<span
class="math inline">\(R\)</span>以内的区城里必须有带有标记的点(自己身带有标记的点，可以认为与其距离为0的地方有一个带有标记的点)。
在满足这个条件的情况下，希望能为尽可能少的点添加标记。请问至少要有多少点被加上标记?<br />
<img data-src="../images/NOI暑假培训/算法专题/贪心/POJ-3069%20示意图.png" /></p>
<p><strong>思路</strong><br />
我们可以让这条直线上点的尽可能的被不相交的半径为<span
class="math inline">\(r\)</span>的圆给覆盖，这样可以达到覆盖效率的最大化。具体到代码编写上，可以先从最左边的点开始覆盖<span
class="math inline">\(r\)</span>以内的点并找到标记点，再覆盖标记点右边<span
class="math inline">\(r\)</span>以内的点，依次往下形成若干个不相交的圆。</p>
<p><strong>代码</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e3</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> r<span class="token punctuation">;</span>
<span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>r<span class="token operator">>></span>n <span class="token operator">&amp;&amp;</span> r<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> cin <span class="token operator">>></span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span> dis<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> s <span class="token operator">=</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> s<span class="token operator">+</span>r<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> p <span class="token operator">=</span> dis<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> p<span class="token operator">+</span>r<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
			ans<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> </code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：对计算机科学的反思</title>
    <url>/posts/38145.html</url>
    <content><![CDATA[<blockquote>
<p>作者：李国杰</p>
</blockquote>
<p>从第1台电子计算机问世到现在已经60年了,尽管计算机科学和技术继续保持高速发展的态势，但是<strong>计算机科学与技术不能再采用以往一样的方式发展，需要革命性的突破。</strong>如果一直顺着过去形成的惯性发展，计算机科学的路子可能会越走越窄。我们需要静下心来，认真进行反思，总结经验和教训，以便将来更快更好地发展。</p>
<h2 id="计算机科学的迷途">计算机科学的迷途</h2>
<h3
id="计算机科学不应以把解决方案搞复杂为荣">1．计算机科学不应以把解决方案搞复杂为荣</h3>
<p>普遍认为，计算机科学是“算法的科学”。美国计算机学会（ACM）对计算机科学有如下的定义：Computer
Science as the "systematic study of algorithmic processes that describe
and transform information: their theory, analysis, design, efficiency,
implementation and
application"。算法研究应该是计算机科学的重要内容，但是从某些意义上讲，<strong>计算机科学“成也算法，败也算法”。</strong></p>
<p>计算机科学有两个基础：可计算性和计算复杂性。可惜，目前学习可计算性的主要兴趣在证明某些问题不可计算；学习计算复杂性的主要兴趣在证明NP困难问题。在其他学科中很少见到科学家对不可解或实际上几乎不可解的问题有这么大的兴趣。电子工程科学真正帮助了电路设计，如芯片设计的EDA工具在集成电路产业发展中功不可没。但计算机科学并没有大大减轻编软件的困难，软件设计理论的确需要革命性的突破。</p>
<p>上世纪70年代有一本书《计算机和不可解性（Computers and
Intractability）》，作者是M. R. Garey和D. S.
Johnson，很多学校都采用作为本科高年级或研究生教材，影响很大。这本书的扉页上有一张漫画，漫画中一个人说：这个问题我不能解决，但是你也不能解决，因为它是NP完全问题。说话那个人表现出十分得意的样子。这幅漫画影响了计算机界几十年，从事计算机科学研究的人对解决不了实际需要攻克的困难问题一般不会有任何内疚，因为这是大家都解决不了的NP问题。这种导向对计算机科学已产生了不好的影响。我们真正需要的不是发现一些理论上复杂的问题，而是要在用户满意的前提下尽可能有效地解决实际存在的复杂问题。<strong>计算机科学不应以把解决方案搞复杂为荣，尽可能用简单方法处理复杂问题是信息技术的生存之道</strong>。</p>
<h3
id="应当重视确定可有效求解的问题边界">2．应当重视确定可有效求解的问题边界</h3>
<p>我们做的研究工作多数是改进前人的算法或理论模型，至于沿着已开辟的方向究竟还有多大改进的余地却很少考虑，很可能这一方向已到了可有效求解的问题边界，而另一方向有很广阔的改进空间我们反而没有触及。</p>
<p>15年前，美国纽约大学的施瓦茨（Schwartz）教授在智能中心做过一个报告。他说，数学上已知的（knowable）问题边界极不规则（如图1所示）。就像油田开采一样，在某个位置钻井有油，偏离一点就没有油。问题的可解性也很类似，某个问题在某些条件下是易解的，但是如果条件稍微改变一点点就很难解甚至不可解了。<strong>确定可有效求解的问题边界，应该是计算机科学的重要内容。</strong></p>
<p><img data-src="http://www.ict.ac.cn/liguojiewenxuan_162523/wzlj/lgjjs/201912/W020191227653419843594.jpg" /></p>
<p><strong>图1 数学上已知的问题边界极不规则</strong></p>
<h3 id="并行处理不是万能药">3．并行处理不是万能药</h3>
<p>并行计算的成功与逐步普及容易使人产生错觉，只要是单机难以解决的问题就想求助于并行计算机，但并行计算并不是万能药。</p>
<p>计算机算法大致上可分成三类：（1）线性或几乎是线性复杂性的算法，如分类（sorting）、商务处理等；（2）多项式或较低的指数复杂性算法，如矩阵运算等；（3）指数复杂性算法，如各种模式转换、规划（planning）等。第一类算法一般可用微机或服务器实现；第二类算法和问题规模大或有实时要求的第一类算法需要并行计算机。已知的第二类算法几乎都是科学计算。超级计算对第三类算法帮助不大，加速100万倍也只能稍稍扩大求解问题规模，需要寻找新的思路。</p>
<p>线性提高并行处理能力不可能对付指数增长的组合爆炸问题（NP问题）。解决人工智能等问题的非确定算法（如搜索算法）在并行处理中，会出现加速比远远超过处理机数的异常现象（好的异常），但我的博士论文《组合搜索的并行处理（Parallel
Processing for Combinatorial
Search）》已经证明，好的异常和坏的异常（并行不如串行）要么都存在，要么都不存在。除非能开发出指数增长的并行处理能力，否则用生物计算机的所谓海量并行也不可能有效地解决组合爆炸问题。<strong>解决人工智能等组合爆炸问题的根本出路在于对所求解问题本身的深入理解。</strong></p>
<h2
id="计算机科学不仅要研究复杂性还要研究简单性">计算机科学不仅要研究复杂性，还要研究“简单性”</h2>
<h3 id="复杂性与简单性">1．复杂性与简单性</h3>
<p>大多数理论计算机科学家热衷于发现人为的难题，而不是寻求有效的方法解决实际问题。我们不仅需要刻画问题困难程度的“复杂性理论”，计算机科学可能更需要建立“简单性理论”，即如何发现最简单的方法去解决实际问题。由于易解问题的边界极不规则，我们特别需要一种理论指导算法设计者选择努力的方向，需要知道往某一方向努力理论上还有多大的改进空间。</p>
<p>例如，热力学中有一个著名的卡诺循环（Carnot
Cycle），其理论表述很简单：</p>
<p>卡诺效率（Carnot Efficiency） = 1 – Tc/Th</p>
<p>Tc和Th分别代表热机工作环境的低温和高温。这一极简单的定律对热机的设计起到非常大的作用。但是，在计算机科学里似乎从未见过这样简洁的对实际设计有指导意义的公式。</p>
<h3
id="驾驭复杂性是信息技术创新的基本问题">2．驾驭复杂性是信息技术创新的基本问题</h3>
<p>人工智能领域权威学者布鲁克斯（Brooks）说过：“<strong>复杂性是致命的敌人</strong>。”系统复杂性研究已成为21世纪最重要的科学内容，但计算机领域的科研人员对这一最活跃的领域似乎关注不够。在钱学森等老科学家的倡导下，我国学者在复杂巨系统和定性定量相结合的研究上已取得不少成果，有些成果应对计算机科学家有重要借鉴意义。</p>
<p>信息技术发展的历史证明：信息技术发展遵循简单性法则，过于复杂的技术往往被淘汰或变成脱离主流的技术，如Ada语言、数据流计算机、B-ISDN（宽带综合业务数字网络）技术等。互联网成功的原因之一在于KISS原则（Keep
It Simple and
Stupid）。<strong>我们应认真总结计算机的发展史，从中发现驾驭复杂性的规律，为计算机领域的技术创新导航。</strong></p>
<h2
id="计算机科学要为技术实现化难为易提供科学指南">计算机科学要为技术实现“化难为易”提供科学指南</h2>
<p>以往的计算机科学为技术实现“化难为易”已经提供了一些科学指南，但是做得还不够。作为一门具有指导意义的科学，计算机科学应该做得更好一些。在“化难为易”方面，下面几个问题值得我们深思。</p>
<h3
id="降低问题复杂性的关键是选择合适的问题表述">1．降低问题复杂性的关键是选择合适的问题表述</h3>
<p>我刚从美国回国工作时，有感于国内不重视不同于“计算方法”的算法研究，曾呼吁过国内要大力开展真正的算法研究，现在我感到要强调问题的另一面。一类问题的复杂性取决于它的问题表述（问题复杂性可能是计算机科学中很少有的不变量），只要问题表述没有改变，解决某一类问题的算法复杂性的下限就不可能改变。我们花了很多功夫优化算法，但却很少花功夫寻找合适的问题表述，可能是捡了芝麻丢了西瓜。有些所谓NP困难问题并不反映实际问题的本质“简单性”，比如识别人脸对人脑而言可能就是一个简单问题。我们不应研究人如何“绕过”了指数爆炸，而是要研究我们采用的人脸识别表述方法如何把我们引入了指数爆炸的歧路，我们需要做的事情是选择对人脸数据的简单描述的模式。</p>
<h3
id="改变问题分解的途径可大幅度提高问题求解效率">2．改变问题分解的途径可大幅度提高问题求解效率</h3>
<p>我在美国做博士论文研究时，常常采用把一个问题分解成许多子问题的途径来解决复杂问题，这是计算机科学里最常用的Divide
and Conquer方法。最近我的导师Benjamin
Wan教授告诉我，对有些问题，他现在采用分解限制条件的办法比传统的子问题分解，求解效率可高出上千倍。有些实际问题，像机场的实时调度，可能有上百种限制条件。传统的求解方法是通过问题分解去缩小问题规模，如先分解到部门一级再综合。这样分解后的每一个子问题的复杂性并没有减少。但如果对限制条件进行分解，分解后的每个小问题只包含很少的限制，这样的小问题就极其简单，实际的求解效率可大大提高。</p>
<h3 id="虚拟化是化繁为简的关键技术">3．虚拟化是化繁为简的关键技术</h3>
<p>一部计算机发展的历史可看作计算机技术不断虚拟化的历史。上世纪70年代，IBM
370首先使用虚拟计算机概念。1992年布特勒·兰普森在获得图灵奖时引用别人的话说过：“计算机科学中的任何问题都可以通过另外一个层次解决。”计算机产业的发展不可能完全做到先提出完美的顶层设计再按既定的标准发展，标准往往是在竞争中形成的。为了解决发展过程中互操作和兼容等问题，常常通过虚拟机的思路在更高的层次隐藏下一层的技术细节。<strong>我们要把虚拟机的思想理论化，使之成为计算机科学的重要内容。</strong></p>
<h2
id="计算机科学应重点突破技术发展的限制">计算机科学应重点突破技术发展的限制</h2>
<h3 id="一味提高速度不是明智的选择">1．一味提高速度不是明智的选择</h3>
<p>这些年来，计算机技术的高速发展得益于摩尔（Moore）定律，所以不少人言必称摩尔定律。其实，计算机技术的发展也受害于摩尔定律。CPU和计算机性能的不断提高，确实缓解了某些过去不容易解决的困难，但也掩盖了计算机科学中的一些基本矛盾，许多问题都指望通过计算机性能提高来解决。现在，<strong>芯片和计算机性能的提高已遇到功耗、可靠性和成本三面高墙，</strong>计算机科学应重点突破这些技术发展的限制。例如，像现在这样无限制地扩大芯片面积和集成度，一个芯片里集成几亿甚至几十亿个晶体管，造成功耗很大，成本不断增加，可靠性降低。近来许多专家都指出，一味地从提高芯片和计算机的速度上找出路不是一个明智的选择。</p>
<p>芯片器件的复杂性每年增长68％，到2018年单芯片内晶体管数预计将超过140亿个，而芯片设计能力（每个人月设计的晶体管数）每年只增长21％（CPU内大量的芯片面积只能用来做增值不高的缓存）。集成电路产业的瓶颈在芯片设计，若不能有效掌控芯片的复杂性，即使有了10纳米的新工艺，潜在的芯片能力也发挥不出来。怎样才能把芯片所能提供的能力尽量发掘出来，需要在计算机科学上有所突破。</p>
<h3 id="吸取工业化进程的教训">2．吸取工业化进程的教训</h3>
<p>我们应该从过去工业化的进程中吸取教训。几十年前，不管是化工还是钢铁，我们的前辈在实现工业化的过程中，并没有认识到他们的做法有什么不对。现在，到了我们这一代，我们发现有很多不合理的地方：没有给我们留下一个美好的环境，污染严重，浪费资源等等。我担心再过50年，我们的后人说，21世纪初有那么一批很蠢的计算机科学家，他们搞的信息化造成很多问题，浪费了很多资源，对人类文明也是一种浪费。我想，<strong>与其将来被别人批判，还不如我们自己批判自己，走一条更加符合人类社会发展规律的道路</strong>。我们需要反思：计算机科学技术是不是也走了一些弯路，是否应该探索革命性的突破？</p>
<h2 id="计算机科学要寻求大的突破">计算机科学要寻求大的突破</h2>
<p>计算机科学的发展已经到了相对成熟的阶段，如何继续向前发展是每一位计算机科学家需要认真思考的问题。我们需要摆脱过去已经取得的成就的拖累，提出新的发展思路。</p>
<h3 id="重新发明网络和操作系统">1．重新发明网络和操作系统</h3>
<p>最近，美国国家自然基金会（NSF）在计算机和通信网络领域提出了新的研究方向，如投入3亿美金的GENI项目，值得我们注意。美国NSF网络和计算机领域的主管官员赵伟教授告诉我，他的基本思想是要reinvention, 一个是要发明新的网络，另一个是要发明新的操作系统。他们认为，改进互联网应该是思科等公司的事，NSF不必为大公司赚钱操心。当网络带宽达到10Tbps时，分组交换可能已不能有效地工作。现在的互联网只相当于邮政系统，NSF应致力于发明相当Express快件系统的新网络。在操作系统方面，NSF不应再支持研究Unix或Linux，而是要创造新的操作系统。</p>
<p>NSF的科研布局使我想起了美国麻省理工学院（MIT）的“不为”原则：<strong>“不做只要努力一定能成功的课题”</strong>，即要做没有成功把握的研究。我国863计划中有不少工程性很强的项目，要求一定成功是无可非议的。但即使是基金和973项目中，带有reinvention 性质的项目也不多。今后，我们需要做一些目前还不能保证成功的研究。</p>
<h3
id="内容处理已成为必须突破的核心技术">2．内容处理已成为必须突破的核心技术</h3>
<p>当前，内容处理已成为网络浏览检索、软件集成（Web服务）、网格等计算机应用的瓶颈，语义处理也是下一代操作系统的核心技术。形形色色的软件技术最终都卡在语义上，语义处理已成为需要突破的关键技术。人工智能、模式识别等技术已有相当进展，但内容处理还处于重大技术突破的前夜，究竟什么时候能真正取得突破性的进展现在还难以预见。</p>
<p>冯·诺依曼的最大贡献是提出了在单台计算机上把程序视同为数据的程序存储式计算机模型，而语义研究的目标是在整个网络上实现将程序视同为数据。目前的浏览器已能做到不区分本地和远程的数据，将来可能实现的基于语义的操作系统应做到不区分本地和远程的程序。也就是说，<strong>我们的目标是实现广义的冯·诺依曼计算机，即联网的计算机真正变成一台计算机，在全球网络上实现程序等同于数据</strong>。这是计算机科学家梦寐以求的理想，我们要持之以恒地追求。</p>
<h2
id="计算机科学要成为提高办事效率与质量的事理学">计算机科学要成为提高办事效率与质量的“事理学”</h2>
<h3 id="计算机科学本质上是事理学">1．计算机科学本质上是"事理学"</h3>
<p>相对于研究物质结构原理的物理学，计算机科学本质上是研究做事效率和成本的“事理学”。所谓做事包括科学工程计算、事务处理、信息服务等各种人类想做的事情。</p>
<p>办事就要讲求章法、讲求系统、讲求组织，不仅仅是算法。盖一幢大楼，包括土木、水电、供暖等各种子系统，建筑公司可以做到相互配合井井有条；但编制大型软件失败的项目比比皆是，原因多半出在各部件和子系统无法协调配合。我们应不应该反思：计算机科学究竟缺了些什么？这里面可能有些根本性的规律我们没有掌握，怎么把一个事情做成功、做好，不仅仅是一个算法优化问题。</p>
<h3 id="关注服务科学">2．关注服务科学</h3>
<p>最近，IBM公司提出一个新的目标，叫做服务科学（Service
Sciences）。专家们认为，服务科学可以将计算机科学、运筹学、产业工程、数学、管理学、决策学、社会学和法律学在既定领域内融合在一起，创建新的技能和市场来提供高价值的服务。促进技术和商务更紧密结合需要新的技能和技能组合，这些技能和应用方法必须从大学起开始教授，创建“服务科学”学科的想法从此诞生。</p>
<p>在美国，整个服务行业创造的价值已占全部GDP的70%以上，服务也需要科学做指导。IBM提出的服务科学全称是SSME，即服务科学、管理和工程，将服务看成科学、管理和工程的结合，把计算机和商务紧密联系起来了。美国很多学校已经开设了服务科学课程，将来培养出来的就是美国的行业工程师。若干年前，当有人从计算机硬件软件中提炼出计算机科学时，不少人奚落嘲笑；<strong>现在服务科学刚刚出现地平线上，我们不应当挑剔它的幼稚，要以敏锐的洞察力捕捉先机。</strong></p>
<h2
id="计算机科学应成为跨领域的二元或多元科学">计算机科学应成为跨领域的二元或多元科学</h2>
<h3 id="寻找被打断的沟通链条">1．寻找被打断的“沟通链条”</h3>
<p>近代科学学科划分过细、条块分割，反而模糊了人们对事物的总体性、全局性的认识。德国著名的物理学家普朗克认为：“<strong>科学是内在的整体，它被分解为单独的部分不是取决于事物本身，而是取决于人类认识能力的局限性。实际上存在从物理到化学，通过生物学和人类学到社会学的连续的链条，这是任何一处都不能被打断的链条</strong>”。</p>
<p>早在100多年前，马克思在《经济学--哲学手稿》中曾预言：“<strong>自然科学往后将会把关于人类的科学总括在自己下面，正如同关于人类的科学把自然科学总括在自己下面一样，它将成为一个科学。</strong>”面对着越来越复杂的问题，许多研究者开始探索从整体出发的研究方法，试图寻找那条被打断的“沟通链条”。</p>
<h3
id="形成跨领域的二元或多元计算机科学">2．形成跨领域的二元或多元计算机科学</h3>
<p>计算机科学需要强调与自然科学、社会科学的交叉，应该成为跨领域的二元或多元科学。将计算机学科分成科学与工程已不合时宜，南加州大学不再按照体系结构作分界线区分计算机科学和计算机工程，而是按分析与综合分类的新框架做区分，以分析为主的叫科学，以综合为主的叫工程，计算机科学主要内容是跨学科的分析，计算机工程主要从事面向系统的综合。计算机科学要大大加强与物理学、生命科学及社会科学的交叉研究，形成计算物理学、计算生物学、社会计算等新学科，还可以形成“计算机+生命+物理”、“计算机+生命+社会”等三元交叉科学。这些交叉学科不仅仅是计算机的应用扩展，而是我们需要高度重视的计算机科学的未来主流方向。要做好这些交叉学科研究，必须加强以超级计算机为基础的计算机模拟与仿真。我们不能认为在Computer+X的交叉学科中，计算机只不过是一个工具。实际上这是若干新的科学，<strong>它既不是传统的计算机科学，也不是原来的X学，而是把这两方面或几方面融合起来的新科学</strong>。</p>
<p>计算机的发展对未来人类社会也将有重大影响。计算机科学家不但要和其他领域的自然科学家合作，还需要和社会学、经济学、新闻传播等方面的社会科学家更密切地合作。总之，<strong>今后计算机科学的研究，不能完全像过去一样走越分越细的以归约还原为主的道路，应当考虑走一条强调综合集成的新道路。</strong></p>
<h2 id="对计算机学科教育的反思">对计算机学科教育的反思</h2>
<p>和美国NSF信息学部主任赵伟教授的一次对话引起我一些反思，赵伟教授认为，美国学科教育的发展有不同模式，有些封闭保守，有些开放包容。美国较好的学科教育发展模式可能是医学院和法学院，所有相关的知识都吸纳在本学院里，其他的学院一般不教医学和法律课程。工程学科也有较好的吸纳性，其他学院一般不会开设电路设计课。但计算机学科是发散的学科，其他学院可开设各种与计算机有关的课程。计算机科学会不会像数学一样把相关的知识都推出去，只剩下很少的内容？计算机学院将来教什么课？</p>
<p>我国一些计算机教育专家也发现了同样的问题，他们担心计算机科学将逐步变成与现在数学差不多成为一门公共课。其实，如上所述，计算机科学方兴未艾，还有许多计算机科学应该重视的内容尚没有我们进入我们的视野，尤其是<strong>计算机科学与自然科学、社会科学的交叉将会大大充实计算机科学的内涵。我们真应当好好梳理一下，不要懵懵懂懂把计算机科学引入了很窄的死胡同。</strong></p>
<h2 id="致谢">致谢</h2>
<p>本文有些观点是在与美国NSF信息学部主任赵伟教授及其他学者讨论中形成的，在此一并表示感谢。</p>
<hr />
<p>文章出处：<br />
<a
href="http://ict.cas.cn/liguojiewenxuan_162523/wzlj/lgjjs/201912/t20191227_5476650.html">对计算机科学的反思</a></p>
]]></content>
      <categories>
        <category>优质文章转载</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>blog</tag>
        <tag>文摘</tag>
      </tags>
  </entry>
  <entry>
    <title>递归与递推</title>
    <url>/posts/40459.html</url>
    <content><![CDATA[<blockquote>
<p><strong>简单来说，递归就是自上而下，而递推则是自下而上，二者可以相互转化</strong></p>
</blockquote>
<p>函数自己调用自己的行为就叫做递归，对于重复的子步骤，我们就可以使用递归来求解</p>
<p>例如斐波拉契数列，其当前项等于前两项之和，要求<span
class="math inline">\(fib(n)\)</span>则需要先求出<span
class="math inline">\(fib(n-1)\)</span>和<span
class="math inline">\(fib(n-2)\)</span>，要求出<span
class="math inline">\(fib(n-1)\)</span>则需要先求出<span
class="math inline">\(fib(n-2)\)</span>和<span
class="math inline">\(fib(n-3)\)</span>，<span
class="math inline">\(\cdots\)</span></p>
<p>但是这个子过程求到最后一定可以找到我们已知的值，比如我们知道斐波拉契数列第一项和第二项都是1，然后向上返回求解。否则这个问题就会不断向下求解子问题，无穷无尽。</p>
<p>依照这个过程，我们可以将<span
class="math inline">\(fib\)</span>定义为一个函数，于是有以下求解过程：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>实际运行的时候我们会发现就算是求解<span
class="math inline">\(fib(40)\)</span>这样<span
class="math inline">\(n\)</span>较小的结果，也要花费相当长的时间，因为其递归求解时，会像下图一样按照指数级别扩展开来：<br />
<img data-src="../images/NOI暑假培训/算法专题/斐波拉契递归调用示意图.png" /></p>
<p>但是如果我们计算一次之后，就用用数列将结果存储起来，不用计算重复的结果，那速度会变得快不少，因此就有了下面的递推写法：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p><strong>递推的思路</strong>可以归纳如下：</p>
<ol type="1">
<li>定义你想要的状态，比如斐波拉契数列里面<span
class="math inline">\(f[i]\)</span>就代表当前第<span
class="math inline">\(i\)</span>个斐波拉契数列的值</li>
<li>找递推关系</li>
<li>找递推边界</li>
</ol>
<p>受到斐波拉契数列求解方法的启发，我们来试试<a
href="https://vjudge.net/problem/51Nod-2115">上台阶</a>这道题目：</p>
<p>同理，当前台阶<span
class="math inline">\(i\)</span>可以由之前走一步和走两步递推而来</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e5</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">,</span> mod <span class="token operator">=</span> <span class="token number">100003</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> f<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>
    f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">%</span>mod<span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">%</span>mod<span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</code></pre>
<p>接下来我们再看看一道很经典的递归题目—<a
href="https://vjudge.net/problem/OpenJ_Bailian-4147">汉诺塔问题</a></p>
<p>有三根杆子<span class="math inline">\(a,b,c\)</span>。<span
class="math inline">\(a\)</span>杆上有 <span
class="math inline">\(n\)</span>
个穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 <span
class="math inline">\(c\)</span> 杆：</p>
<ol type="1">
<li>每次只能移动一个圆盘；</li>
<li>大盘不能叠在小盘上面。</li>
</ol>
<p>其求解步骤如下：<br />
<img data-src="../images/NOI暑假培训/算法专题/汉诺塔问题求解步骤.png" /></p>
<p>具体代码实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e5</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>
<span class="token keyword">int</span> h<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> a<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">,</span> <span class="token keyword">char</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token function">move</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cnt<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//记录移动步数 </span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">move</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	cin <span class="token operator">>></span> n<span class="token punctuation">;</span>
	<span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//	h[1] = 1;</span>
<span class="token comment">//	for(int i = 2; i &lt;= n; i++)</span>
<span class="token comment">//		h[i] = 2*h[i-1] + 1;</span>
<span class="token comment">//	cout &lt;&lt; cnt &lt;&lt; " " &lt;&lt; h[n];</span>
<span class="token punctuation">&#125;</span> </code></pre>
<p>同时，若我们将<span class="math inline">\(h_{n}\)</span>表示为把<span
class="math inline">\(n\)</span>个盘子从<span
class="math inline">\(a\)</span>挪到<span
class="math inline">\(c\)</span>所需要的次数。结合上面的求解示意图，很容易就能发现：总时先借助<span
class="math inline">\(c\)</span>柱把上面的<span
class="math inline">\(n-1\)</span>个盘子移动到<span
class="math inline">\(b\)</span>柱，接着把<span
class="math inline">\(a\)</span>最下面的盘子挪到<span
class="math inline">\(c\)</span>柱上，最后把<span
class="math inline">\(b\)</span>上的<span
class="math inline">\(n-1\)</span>个盘子移动到<span
class="math inline">\(c\)</span>柱上，由于实际上每个柱的编号不重要，可以得出移动次数为：<span
class="math inline">\(h_{n-1}+1+h_{n-1}\)</span></p>
<p>于是得到递推表达式：<span
class="math inline">\(h_n=2*h_{n-1}+1\)</span>，边界条件为<span
class="math inline">\(h_1=1\)</span></p>
<p>求解汉诺塔问题移动次数的具体实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	h<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>h<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre>
<p>最后留下一道<a
href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-T2118">过河卒</a>作为练习，其代码实现如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">//马可以走到的位置</span>
<span class="token keyword">int</span> bx<span class="token punctuation">,</span> by<span class="token punctuation">,</span> mx<span class="token punctuation">,</span> my<span class="token punctuation">;</span>
ll f<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> s<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//判断这个点有没有马拦住</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>by<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>my<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bx <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">,</span> by <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">,</span> mx <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">,</span> my <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//坐标+1以防越界</span>
    <span class="token comment">//下面两行代码表示标记马的位置</span>
    s<span class="token punctuation">[</span>mx<span class="token punctuation">]</span><span class="token punctuation">[</span>my<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> s<span class="token punctuation">[</span>mx<span class="token operator">+</span>dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>my<span class="token operator">+</span>dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//初始化</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bx<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> by<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">||</span>i<span class="token operator">*</span>j<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 如果被马拦住就直接跳过</span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//状态转移方程</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>bx<span class="token punctuation">]</span><span class="token punctuation">[</span>by<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> </code></pre>
<hr />
<p>参考自：<br />
《信息学奥赛一本通》<br />
《挑战程序设计竞赛》</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>技巧与思想</tag>
        <tag>NOI暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度计算</title>
    <url>/posts/61946.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>对于整数，我们平常会使用int类型进行数据运算，再大一点的我们可以使用long
long
int，那么再大一点呢，就没有能够使用的基本数据类型满足我们的要求了。这个时候就需要用到高精度算法了，其实本质上是用数组将每一位都储存起来，进行加减运算的时候手动模拟运算的过程，最终得到结果。</p>
<h3 id="加法">加法</h3>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> c<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">||</span> q<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> tmp <span class="token operator">+=</span> a<span class="token punctuation">[</span><span class="token operator">--</span>p<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> tmp <span class="token operator">+=</span> b<span class="token punctuation">[</span><span class="token operator">--</span>q<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span>
		c<span class="token punctuation">[</span>id<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">,</span> tmp <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> id<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="减法">减法</h3>
<p>减法需要注意的是，如果是小数a减大数b，那么会得到负数，我们会先用大数b减去小数a，再补上负号即可。</p>
<pre class="language-c" data-language="c"><code class="language-c">bool <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> lena <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> lenb <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>lena<span class="token operator">!=</span>lenb<span class="token punctuation">)</span> <span class="token keyword">return</span> lena<span class="token operator">></span>lenb<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lena<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> true<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span>

<span class="token comment">/*
1314 1267
123 123
5 5 少考虑了一种情况，即答案为 00 时，程序不会输出
*/</span>
<span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cmp</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token function">sub</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> c<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		tmp <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token operator">--</span>p<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token operator">-</span>tmp<span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> tmp <span class="token operator">-=</span> b<span class="token punctuation">[</span><span class="token operator">--</span>q<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span>
		c<span class="token punctuation">[</span>id<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>tmp<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
		tmp <span class="token operator">=</span> tmp<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>id<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>id<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span> id <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//删除前导0 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> id<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="乘法">乘法</h3>
<p>类似加法,可以用竖式求乘法。如下图所示：<br />
<img data-src="../images/NOI暑假培训/算法专题/高精度计算乘法.png" /><br />
在做乘法运算时,同样也有进位,同时对每一位进行乘法运算时,必须进行错位相加。分析c数组下标的变化规律,可以写出如下关系式：<br />
<span class="math display">\[c_i=c_i^{&#39;}+
c_i^{&#39;&#39;},+…\]</span><br />
由此可见<span class="math inline">\(c_i\)</span>跟<span
class="math inline">\(a[i]*
b[j]\)</span>乘积有关,跟上次的进位有关,还跟原<span
class="math inline">\(c_i\)</span>的值有关,分析下标规律有：</p>
<pre class="language-c" data-language="c"><code class="language-c">c<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span>＋x＋c<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
x<span class="token operator">=</span>c<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">%=</span><span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
12 12 
0 123
*/</span>
<span class="token keyword">void</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> id <span class="token operator">=</span> p<span class="token operator">+</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
			c<span class="token punctuation">[</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token operator">+</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> p<span class="token operator">+</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			c<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>
			c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%=</span> <span class="token number">10</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>	
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>id<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> id<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> id<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="除法">除法</h3>
<p>模拟除法竖式即可，不过需要注意的是当被除数num为最大范围1e9时，除数可能为9e9超出int范围需要将其定义为long
long ，参考<a
href="https://www.luogu.com.cn/discuss/293101?page=2">讨论区</a></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
高精度整数除以单精度整数的商和余数
9000000000 1000000000

*/</span>
<span class="token keyword">void</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> c<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	ll r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> p<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> r <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		r <span class="token operator">=</span> r<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span>
		c<span class="token punctuation">[</span>id<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token operator">/</span>num<span class="token punctuation">;</span>
		r <span class="token operator">%=</span> num<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	bool flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> id <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token operator">||</span>i<span class="token operator">==</span>id<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token punctuation">&#125;</span>
		
<span class="token punctuation">&#125;</span></code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>publication</tag>
        <tag>NOI暑假集训</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
</search>
